# hspfmodel.py
#
# David J. Lampert (djlampert@gmail.com)
#
# Purpose: Builds an instance of the HSPFModel class that can be used to
# generate UCI files for an HSPF simulation.
#
# last updated: 08/27/2013

from pyhspf.core.wdmutil import WDMUtil

import os, sys, shutil, pickle, datetime, time, math, hspf

class HSPFModel:
    """A class that stores all pertinent information about a watershed for
    building a model for the Hydrologic Simulation Program in Fortran (HSPF)
    User Control Input (UCI) file."""

    def __init__(self, units = 'Metric'):
        """Initialize the model and point to the lib3.0 library."""

        # unit system (English or Metric)

        self.units = units

        # set up dictionaries of external timeseries for the model 
        # (append as needed)

        self.inflows         = {}  # flows into the watershed
        self.precipitations  = {}  # precipitation
        self.evaporations    = {}  # potential evapotranspiration
        self.temperatures    = {}  # temperature
        self.dewpoints       = {}  # dewpoint
        self.windspeeds      = {}  # wind speed
        self.solars          = {}  # solar radiation
        self.flowgages       = {}  # NWIS daily flow gage stations
        self.snowfalls       = {}  # NCDC snowfall depth
        self.snowdepths      = {}  # NCDC snowpack depth
        self.waterquality    = {}  # NWIS water quality data
        self.wateryields     = {}  # water yielded from snowpack
        self.rains           = {}  # rain (NOT snow)
        self.snowcovers      = {}  # snow cover fraction
        self.ices            = {}  # water depth of ice

    def build_from_watershed(self, watershed, filename, directory = None,
                             print_file = None, binary_file = None, tstep = 60, 
                             outlev = 4, spout = 2, units = 2, print_level = 5, 
                             ifraction = 0.5, evap_multiplier = 1., 
                             landuseyear = None, verbose = False):
        """
        Builds a model from an instance of the Watershed class.

        watershed       -- an instance of the watershed class
        start           -- beginning date for simulation
        end             -- end of simulation
        ucifile         -- name given to the UCI file generated by this object
        wdminfile       -- name of the input (meteorology) WDM file
        wdmoutfile      -- name of the WDM file for output data
        print_file      -- name of optional text output file
        binary_file     -- name of optional binary output file
        tstep           -- time step size in minutes (defaults to one hour)
        outlev          -- run interpreter output level (1-10)
        spout           -- special action output level (1-10)
        units           -- english (1) or metric (2)
        print_level     -- output level in optional print_file
        ifraction       -- fraction of developed land assumed to be impervious
        evap_multiplier -- potential evapotranspiration / pan evaporation
        """

        # name from the watershed instance (max 33 characters)

        self.description = watershed.name[:33]

        # paths to working directory for the simulation

        if directory is None: self.filepath = ''
        else:                 self.filepath = directory + '/'

        self.filename = filename

        # path to the messagefile

        directory = os.path.dirname(hspf.__file__)
        self.messagepath = '{}/pyhspf/core/hspfmsg.wdm'.format(directory)

        # add the output levels and units

        self.tstep       = tstep
        self.outlev      = outlev
        self.spout       = spout
        self.print_level = print_level
        self.print_file  = print_file
        self.binary_file = binary_file

        # set up the parameters for the perlnds

        self.evap_multiplier = evap_multiplier
        self.ifraction       = ifraction

        # attach the "updown" dictionary for mass linkages to the model

        self.updown = watershed.updown

        # attach the subbasins to the model

        self.subbasins = watershed.subbasins

        # attach the inlets and outlets to the model

        self.inlets  = watershed.inlets
        self.outlets = watershed.outlets

        # specify the land use year

        self.landuseyear = landuseyear

        # build it

        self.build()

    def build_from_existing(self, hspfmodel, filename, directory = None,
                             print_file = None, binary_file = None, tstep = 60, 
                             outlev = 4, spout = 2, units = 2, print_level = 5, 
                             ifraction = 0.5, evap_multiplier = 0.7, 
                             landuseyear = None, verbose = False):
        """
        Builds a model from another instance of the HSPFModel class (for 
        running similar models or submodels).

        watershed       -- an instance of the watershed class
        start           -- beginning date for simulation
        end             -- end of simulation
        ucifile         -- name given to the UCI file generated by this object
        wdminfile       -- name of the input (meteorology) WDM file
        wdmoutfile      -- name of the WDM file for output data
        print_file      -- name of optional text output file
        binary_file     -- name of optional binary output file
        tstep           -- time step size in minutes (defaults to one hour)
        outlev          -- run interpreter output level (1-10)
        spout           -- special action output level (1-10)
        units           -- english (1) or metric (2) -- English NOT implemented
        print_level     -- output level in optional print_file
        ifraction       -- fraction of developed land assumed to be impervious
        evap_multiplier -- potential evapotranspiration / pan evaporation
        """

        # name from the watershed instance

        self.description = hspfmodel.description

        # paths to working directory for the simulation

        if directory is None: self.filepath  = ''
        else:                 self.filepath  = directory + '/'

        self.filename = filename

        # path to the messagefile

        directory = os.path.dirname(hspf.__file__)
        self.messagepath = '{}/pyhspf/core/hspfmsg.wdm'.format(directory)

        # add the output levels and units
        
        self.tstep       = tstep
        self.outlev      = outlev
        self.spout       = spout
        self.print_level = print_level
        self.print_file  = print_file
        self.binary_file = binary_file

        # set up the parameters for the perlnds

        self.evap_multiplier = evap_multiplier
        self.ifraction       = ifraction

        # attach the "updown" dictionary for mass linkages to the model

        self.updown = hspfmodel.updown

        # attach the subbasins to the model

        self.subbasins = hspfmodel.subbasins

        # attach the inlets and outlets to the model

        self.inlets  = hspfmodel.inlets
        self.outlets = hspfmodel.outlets

        # specify the land use year

        self.landuseyear = hspfmodel.landuseyear

        # build it

        self.build()

    def build(self):
        """Calculates everything needed to run HSPF."""
       
        # check time step size

        if 1440 % self.tstep != 0: 
            print('warning: specified time step is invalid, converting')
            while 1440 % self.tstep != 0: self.tstep -= 1

        # calculate tsstep and tcode

        self.tcode, self.tsstep = self.get_timestep(self.tstep)
        
        # order operations from upstream to downstream using updown dictionary
        
        # divide the subbasins into rows and put them on the chart
        # start at the bottom to organize the linkages better

        rows = [self.outlets]

        top = False
        while not top:
            rows.insert(0, [])
            for next in rows[1]:
                for subbasin in self.updown:
                    if self.updown[subbasin] == next: 
                        rows[0].append(subbasin)
            if len(rows[0]) == 0:
                rows.remove(rows[0])
                top = True

        subbasin_network = []
        for row in rows: 
            for comid in row: subbasin_network.append(comid)

        # keep track of the land segments in each subbasin

        self.landtypes = {}

        # make the operations

        r = 1    # the number assigned to the current rchres and ftable
        p = 100  # the number assigned to the current perlnd
        i = 100  # the number assigned to the current implnd

        rchreses = []
        perlnds  = []
        implnds  = []

        for comid in subbasin_network:

            subbasin = self.subbasins[comid]

            self.landtypes[comid] = {}

            # assign the reach

            delth  = (subbasin.reach.maxelev - subbasin.reach.minelev) / 100
            flow   = (subbasin.reach.inflow + subbasin.reach.outflow) / 2

            # minor work around for empty gnis names

            if isinstance(subbasin.reach.gnis, bytes): gnis = ''
            else: gnis = subbasin.reach.gnis
            
            reach = Rchres(r, subbasin.comid, gnis, subbasin.reach.slopelen, 
                           delth, flow, subbasin.reach.velocity, 
                           ftable = subbasin.reach.ftable, 
                           dam = subbasin.reach.dam)
            rchreses.append(reach)
            self.landtypes[comid]['Reach'] = reach
            r += 1
        
            if self.landuseyear is None: 
                landuse = subbasin.landuse[min(subbasin.landuse.keys())]
            else: 
                landuse = subbasin.landuse[self.landuseyear]

            for landtype, area in landuse.items():

                if landtype == 'Developed':
                    
                    # add an implnd

                    impervious_area = self.ifraction * area
                    pervious_area = (1 - self.ifraction) * area

                    implnd = Implnd(i, subbasin.comid, impervious_area,
                                    subbasin.flowplane.length,
                                    subbasin.flowplane.slope,
                                    subbasin.flowplane.avgelev,
                                    subbasin.flowplane.centroid[1])
                    implnds.append(implnd)
                    self.landtypes[comid]['Impervious'] = implnd
                    i += 1
                    
                else: pervious_area = area

                # add the perlnd

                perlnd = Perlnd(p, subbasin.comid, landtype, pervious_area,
                                subbasin.flowplane.length,
                                subbasin.flowplane.slope,
                                subbasin.flowplane.avgelev, 
                                round(subbasin.reach.minelev / 100),
                                subbasin.flowplane.centroid[1])
                perlnds.append(perlnd)
                self.landtypes[comid][landtype] = perlnd
                p += 1           

        # make a list of all the landuse types specified

        self.landuse = list(set([l for c in self.landtypes 
                                 for l in self.landtypes[c] if l != 'Reach']))

        # attach the operations to the model

        self.perlnds   = perlnds
        self.implnds   = implnds
        self.rchreses  = rchreses

        # set up the time series for the whole watershed

        self.watershed_timeseries = {}

        # set up the time series specific to each the subbasin

        self.subbasin_timeseries = {s:{} for s in self.subbasins}

        # set up the time series specific to each landuse category

        self.landuse_timeseries = {l:{} for l in self.landuse}

        # set up the time series specific to each operation

        self.operation_timeseries = {comid:{l:{} for l in dict} 
                                     for comid, dict in self.landtypes.items()}

    def add_timeseries(self, tstype, identifier, start_date, data, tstep = 60):
        """Adds a timeseries of type "tstype" with a unique "identifier"
        and list of data with time step "tstep" (in minutes) and a list of
        data "data" to the model. The units should be appropriate for the
        model simulation or comparison."""

        # inflow is assumed to be volumetric; e.g., Mm3 (ROVOL) not m3/s (RO)

        if   tstype == 'inflow':        d = self.inflows
        elif tstype == 'precipitation': d = self.precipitations
        elif tstype == 'evaporation':   d = self.evaporations
        elif tstype == 'temperature':   d = self.temperatures
        elif tstype == 'dewpoint':      d = self.dewpoints
        elif tstype == 'wind':          d = self.windspeeds
        elif tstype == 'solar':         d = self.solars
        elif tstype == 'flowgage':      d = self.flowgages
        elif tstype == 'snowfall':      d = self.snowfalls
        elif tstype == 'snowdepth':     d = self.snowdepths
        elif tstype == 'wateryield':    d = self.wateryields
        elif tstype == 'rain':          d = self.rains
        elif tstype == 'snowcover':     d = self.snowcovers
        elif tstype == 'ice':           d = self.ices
        else: 
            print('warning: unknown time series type specified')

        d[identifier] = (start_date, tstep, data)

    def assign_watershed_timeseries(self, tstype, identifier):
        """Assigns a timeseries to the whole watershed."""

        self.watershed_timeseries[tstype] = identifier

    def assign_subbasin_timeseries(self, tstype, comid, identifier):
        """Assigns a timeseries to a subbasin."""

        if tstype not in self.subbasin_timeseries:
            self.subbasin_timeseries[tstype] = {}
        self.subbasin_timeseries[tstype][comid] = identifier

    def assign_landuse_timeseries(self, tstype, landuse, identifier):
        """Assigns a timeseries to a landuse category."""

        if tstype not in self.landuse_timeseries:
            self.landuse_timeseries[tstype] = {}
        self.landuse_timeseries[tstype][landuse] = identifier

    def assign_operation_timeseries(self, tstype, subbasin_number, otype, 
                                    identifier):
        """Assigns a timeseries to an operation."""

        if tstype not in self.operation_timeseries:
            self.operation_timeseries[tstype] = {}
        self.operation_timeseries[tstype][subbasin_number][otype] = identifier

    def get_timestep(self, tstep):
        """Gets the value of tstep and tcode based on the time step size in 
        minutes."""

        if tstep % 60 != 0 or tstep < 60: # use minutes
            tcode  = 2
            tsstep = tstep
        elif tstep < 1440:                # use hours
            tcode = 3
            tsstep = tstep // 60
        elif tstep == 1440:
            tcode = 4
            tsstep = 1
        else:
            print('warning: maximum HSPF time step is 1 day\n')
            tcode = None
            tstep = None

        return tcode, tsstep

    def build_wdminfile(self, verbose = False):
        """Builds the input WDM file for an HSPF simulation."""

        # file path

        self.wdminfile = self.filepath + '%s_in.wdm'  % self.filename

        # keep track of the dsns

        self.dsns = []

        wdm = WDMUtil(verbose = verbose, messagepath = self.messagepath)
        wdm.open(self.wdminfile, 'w')
 
        # attributes that don't change

        HUC8 = self.description

        attributes = {'TGROUP': 5,          # pointers units-same as tcode
                      'TSFILL': 0.,         # fill value for no data
                      'COMPFG': 2,          # compression (1 = yes, 2 = no)
                      'VBTIME': 1,          # variable time step (always 1) 
                      'IDSCEN': 'INPUT',    # data type
                      'STANAM': HUC8,       # description
                      }

        # assign unique id for each dataset

        n = 100

        # add all the inflow data

        attributes['TSFORM'] = 2
        attributes['TSTYPE'] = 'FLOW'
        attributes['IDCONS'] = 'FLOW'

        for f in self.inflows:

            start_date, tstep, data = self.inflows[f]

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['DESCRP'] = f
            
            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)
            self.dsns.append([n, f, 'FLOW'])

            n += 1

        # add all the precipitation data

        attributes['TSTYPE'] = 'PREC'
        attributes['TSFORM'] =  2
        attributes['IDCONS'] = 'PREC'

        for p in self.precipitations:

            start_date, tstep, data = self.precipitations[p]

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            # update attributes

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['DESCRP'] = p

            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)
            self.dsns.append([n, p, 'PREC'])

            n += 1

        # add the evaporation data

        attributes['TSTYPE'] = 'EVAP'
        attributes['IDCONS'] = 'EVAP'

        for e in self.evaporations:

            start_date, tstep, data = self.evaporations[e]
            #print('evap', e, start_date, tcode, tsstep, len(data))

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            # update attributes

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['DESCRP'] = e

            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)
            self.dsns.append([n, e, 'EVAP'])

            n += 1

        # add the temperature data

        attributes['TSFORM'] = 3
        attributes['TSTYPE'] = 'TOBS'
        attributes['IDCONS'] = 'TEMP'

        for t in self.temperatures:

            start_date, tstep, data = self.temperatures[t]

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            # update attributes

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['DESCRP'] = t

            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)

            self.dsns.append([n, t, 'TOBS'])

            n += 1

        # add the dewpoint data

        attributes['TSFORM'] = 3
        attributes['TSTYPE'] = 'DEWT'
        attributes['IDCONS'] = 'DTMG'

        for t in self.dewpoints:

            start_date, tstep, data = self.dewpoints[t]

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            # update attributes

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['DESCRP'] = t

            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)

            self.dsns.append([n, t, 'DEWT'])

            n += 1

        # add the wind speed data

        attributes['TSFORM'] = 3
        attributes['TSTYPE'] = 'WIND'
        attributes['IDCONS'] = 'WIND'

        for t in self.windspeeds:

            start_date, tstep, data = self.windspeeds[t]

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            # update attributes

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['DESCRP'] = t

            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)

            self.dsns.append([n, t, 'WIND'])

            n += 1

        # add the solar radiation data

        attributes['TSFORM'] = 3
        attributes['TSTYPE'] = 'SOLR'
        attributes['IDCONS'] = 'SOLR'

        for t in self.solars:

            start_date, tstep, data = self.solars[t]

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            # update attributes

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['DESCRP'] = t

            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)

            self.dsns.append([n, t, 'SOLR'])

            n += 1

        attributes['TSFORM'] = 2
        attributes['TSTYPE'] = 'WYIE'
        attributes['IDCONS'] = 'WYIELD'

        for subbasin in self.wateryields:

            start_date, tstep, data = self.wateryields[subbasin]

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            # update attributes

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['STAID '] = subbasin

            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)

            self.dsns.append([n, subbasin, 'WYIE'])

            n += 1

        attributes['TSFORM'] = 2
        attributes['TSTYPE'] = 'RAIN'
        attributes['IDCONS'] = 'RAIN'

        for subbasin in self.rains:

            start_date, tstep, data = self.rains[subbasin]

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            # update attributes

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['STAID '] = subbasin

            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)

            self.dsns.append([n, subbasin, 'RAIN'])

            n += 1

        attributes['TSFORM'] = 3
        attributes['TSTYPE'] = 'SCOV'
        attributes['IDCONS'] = 'SCOV'

        for subbasin in self.snowcovers:

            start_date, tstep, data = self.snowcovers[subbasin]

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            # update attributes

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['STAID '] = subbasin

            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)

            self.dsns.append([n, subbasin, 'SCOV'])

            n += 1

        attributes['TSFORM'] = 3
        attributes['TSTYPE'] = 'ICE'
        attributes['IDCONS'] = 'ICE'

        for subbasin in self.ices:

            start_date, tstep, data = self.ices[subbasin]

            # calculate tsstep and tcode

            tcode, tsstep = self.get_timestep(tstep)

            # update attributes

            attributes['TSSTEP'] = tsstep
            attributes['TCODE '] = tcode
            attributes['TSBYR '] = start_date.year
            attributes['STAID '] = subbasin

            wdm.create_dataset(self.wdminfile, n, attributes)
            wdm.add_data(self.wdminfile, n, data, start_date)

            self.dsns.append([n, subbasin, 'ICE'])

            n += 1

        # close it up

        wdm.close(self.wdminfile)
        wdm.close_message()

    def set_states(self, states, hydrology = False, snow = False):
        """Set states."""

        # set hydrology states

        if hydrology:

            for p in self.perlnds:

                p.set_pwat_state(CEPS  = states[p.comid][p.landtype]['CEPS'],
                                 SURS  = states[p.comid][p.landtype]['SURS'],
                                 UZS   = states[p.comid][p.landtype]['UZS'], 
                                 IFWS  = states[p.comid][p.landtype]['IFWS'], 
                                 LZS   = states[p.comid][p.landtype]['LZS'], 
                                 AGWS  = states[p.comid][p.landtype]['AGWS'])

            # set the implnd iwater states

            for i in self.implnds:

                i.set_iwat_state1(RETS = states[i.comid][i.landtype]['RETS'])
                i.set_iwat_state1(SURS = states[i.comid][i.landtype]['SURS'])

            # set the rchres states

            for r in self.rchreses:

                r.VOL = states[r.comid][r.landtype]['VOL']

        # set the snow states

        if snow:

            for o in (self.perlnds + self.implnds):

                o.set_snow_init1(packsnow =states[o.comid][o.landtype]['PACKF'],
                                 packice  =states[o.comid][o.landtype]['PACKI'],
                                 packwatr =states[o.comid][o.landtype]['PACKW'])

    def add_temp(self):

        for o in self.perlnds + self.implnds:
            o.ATMP = True
            o.set_atemp_dat()

    def add_snow(self, depth = 0., density = 0.08):
        """Adds the SNOW module to the simulation. Key calibration parameters
        are gage catch efficiency factor (SNOWCF) and the degree day melt
        factor (KMELT).  Also, initial pack depth is placed here as simulations
        often begin in winter (hence non-zero)."""

        for o in self.perlnds + self.implnds:
            o.SNOW = True
            o.set_ice_flag()
            o.set_snow_flags()
            o.set_snow_parm1()
            o.set_snow_parm2()
            o.set_snow_init1(packsnow = depth * density, RDENPF = density)
            o.set_snow_init2()

    def add_hydrology(self):
        """Adds the PWAT and IWAT modules to the PERLNDs and IMPLNDs and the
        HYDR module to the RCHRESs."""

        if   self.units == 'Metric':  u = 2
        elif self.units == 'English': u = 1

        for p in self.perlnds: 
            p.PWAT = True
            p.set_pwat_parms(self.units)
            if p.SNOW: p.CSNO = 1
            else:      p.CSNO = 0

        # set up the parameters for the implnds

        for i in self.implnds: 
            i.IWAT = True
            i.set_iwat_parms(self.units)
            if i.SNOW: i.CSNO = 1
            else:      i.CSNO = 0

        # set up the parameters for the rchreses

        for r in self.rchreses: 
            r.HYFG = True
            r.set_hydr_parms(self.units)

    def add_sediment(self):

        for p in self.perlnds:
            p.SED = True
            p.set_sed_parm1()
            p.set_sed_parm2()
            p.set_sed_parm3()
            p.set_sed_stor()

        for i in self.implnds:

            i.SLD = True
            i.set_sld_parm1()
            i.set_sld_parm2()
            i.set_sld_stor()

        for r in self.rchreses:
            r.SDFG = True
            r.set_sandfg()
            r.set_genparm()
            r.set_sand_pm()
            r.set_silt_pm()
            r.set_clay_pm()
            r.set_ssed_init()
            r.set_bed_init()

    def run(self, verbose = True):
        """Runs a simulation. Optionally allows specification of the path
        to the message file, which if spawning multiple processes may
        improve stability."""

        if verbose: 
            print('attempting HSPF simulation for {}\n'.format(self.ucifile))

        start = time.time()

        # make a copy of the message file to guard against corrupting the
        # original (source of many headaches)

        retcode = hspf.hsppy(self.ucifile, self.messagepath)

        if retcode > 0 and verbose: 
            print('successfully completed simulation in %.1f' %
                  (time.time() - start), 'seconds\n')

    def warmup(self, start, days = 365, iterations = 2, temp = False, 
               snow = False, hydrology = False, sediment = False,
               verbose = False):
        """warms up the values of the state variables by running the several
        iterations of the specified number of days (default runs the first year
        twice). Requires the Postprocessor class."""

        from postprocessor import Postprocessor

        warmup = []

        if snow:      warmup.append('snow_state')
        if hydrology: warmup.append('water_state')

        # run the specified period

        end = start + datetime.timedelta(days = days)

        for i in range(iterations):

            # run the simulation

            self.build_uci(warmup, start, end, temp = temp, snow = snow, 
                           hydrology = hydrology, sediment = sediment,
                           verbose = verbose)
            self.run(verbose = verbose)

            # get the state variables in the perlnds

            p = Postprocessor(self, dates = (start, end))
            states = p.get_states()
            p.close()

            # set the states

            self.set_states(states, hydrology = hydrology, snow = snow)

    def build_uci(self, targets, start, end, states = None, hydrology = False, 
                  temp = False, snow = False, sediment = False, 
                  verbose = False):
        """Builds the User Control Input (UCI) file for an HSPF Simulation."""

        if verbose: print('generating the UCI file from the watershed data\n')

        # file types and name; see HSPF documentation for more explanation  
        # ftypes are the different file classes for HSPF I/O (echo, WDM, etc)
        # funits are the Fortran numbers assigned to the files (10-98)
        # fnames are the names or paths to the files

        self.ucifile    = self.filepath + '%s.uci'     % self.filename
        self.wdmoutfile = self.filepath + '%s_out.wdm' % self.filename

        # echo file for input file processing name (assumed same as uci)

        self.echofile = self.ucifile[:-4] + '.ech'
        
        # external target names

        self.targets = targets

        self.ftypes = ['MESSU',  'WDM1',  'WDM2']
        self.fnames = [self.echofile, self.wdminfile, self.wdmoutfile]
        self.funits = [10,       11,      12]

        if self.print_file is not None: 
            self.ftypes.append('')
            self.fnames.append(self.print_file)
            self.print_no = self.funits[-1] + 1
            self.funits.append(self.print_no)

        if self.binary_file is not None:
            self.ftypes.append('BINO')
            self.fnames.append(self.binary_file)
            self.bin_no = self.funits[-1] + 1
            self.funits.append(self.bin_no)

        # set the initial states if provided (in dictionary form from the
        # Postprocessor class)

        if states is not None: self.set_states(states)

        # "RUN" marks the start of the execution

        lines = ['RUN', '']

        # add the GLOBAL block

        lines = lines + self.global_block(1, start, end)

        # add the FILES block

        lines = lines + self.files_block()

        # add the OPN SEQUENCE block

        lines = lines + self.opn_sequence_block()

        # add the PERLND block

        lines = lines + self.perlnd_block(hydrology = hydrology, 
                                          temp = temp, snow = snow, 
                                          sediment = sediment)

        # add the IMPLND block

        lines = lines + self.implnd_block(hydrology = hydrology, temp = temp,
                                          snow = snow, sediment = sediment)

        # add the RCHRES block if needed

        if hydrology or sediment:

            lines = lines + self.rchres_block(hydrology = hydrology, 
                                              sediment = sediment)

        # add the EXT SOURCES block

        lines = lines + self.ext_sources_block()

        # add the SCHEMATIC and MASS-LINK blocks if needed

        if hydrology or sediment:

            lines = lines + self.schematic_block()

            lines = lines + self.masslink_block(hydrology = hydrology,
                                                sediment = sediment)

        # add the EXT TARGETS block

        lines = lines + self.ext_targets_block(targets, start.year,
                                               verbose = verbose)

        # add the FTABLES block for the RCHRESES if needed

        if hydrology or sediment:

            lines = lines + self.ftables_block()

        # "close" the simulation info

        lines.append('END RUN')

        # write the lines to the uci file

        with open(self.ucifile, 'w') as f:
        
            for line in lines: f.write(line + '\n')

    def add_ext_targets(self, operations, wdm, year, n, otype, group, var, 
                        tsform, tstype, idcons, func, tcode, tsstep,
                        sub1 = 1, sub2 = 1):
        """Utility routine to shorten the external target addition."""
    
        # the values of these attributes don't change

        attributes = {'TSBYR ': year,       # starting year of data
                      'TGROUP': 5,          # pointers units-same as tcode
                      'TSFILL': 0.,         # fill value for no data
                      'COMPFG': 2,          # compression (1 = yes, 2 = no)
                      'VBTIME': 1,          # variable time step (always 1)
                      'IDSCEN': 'SIM',      # data type
                      }

        # time series specific attributes

        attributes['TSTYPE'] = tstype
        attributes['TSFORM'] = tsform
        attributes['IDCONS'] = idcons
        attributes['TSSTEP'] = tsstep
        attributes['TCODE '] = tcode
       
        if   self.units == 'English': tsys = 'ENGL'
        elif self.units == 'Metric':  tsys = 'METR'

        # add a line for each operation's target

        lines = []
        for o in operations:
            if   otype == 'PERLND': attributes['DESCRP'] = o.landtype
            elif otype == 'IMPLND': attributes['DESCRP'] = 'Impervious'
            elif otype == 'RCHRES': attributes['DESCRP'] = 'Reach'
            attributes['STAID '] = str(o.comid)

            t = otype, o.operation, group, var, sub1, sub2, func, n
            l = '{:<6s}{:4d} {:<6s} {:6s}{:2d}{:2d}{:>14s} WDM2{:6d}'.format(*t)
            lines.append(l + ' {:6s} 1 {:4} AGGR REPL'.format(tstype, tsys))

            # add the dataset to the WDM file

            wdm.create_dataset(self.wdmoutfile, n, attributes)
            n+=1

        return lines

    def ext_targets_block(self, targets, year, verbose = False):
        """Adds the EXT TARGETS block to a UCI file and creates the output WDM 
        file."""
        
        lines = ['EXT TARGETS',
                 '<-Volume-> <-Grp> <-Member-><--Mult-->Tran <-Volume->' +
                 ' <Member> Tsys Aggr Amd ***',
                 '<Name>   x        <Name> x x<-factor->strg <Name>' +
                 '   x <Name>qf  tem strg strg***']
    
        wdm = WDMUtil(verbose = verbose, messagepath = self.messagepath)
        wdm.open(self.wdmoutfile, 'w')

        # dataset numbers are assigned by reach in order (subject to revision)
        # keep track of dsns in a dictionary

        n = 1

        # keep up with flows

        if 'reach_flow' in targets:

            otype  = 'RCHRES'    # HSPF operation type
            group  = 'HYDR'      # HSPF group
            var    = 'RO'        # HSPF variable name
            tsform = 3           # 1-mean, 2-total, 3-instant
            tstype = 'FLOW'      # time series type
            idcons = 'RO'        # constituent id
            func   = 'SAME'      # transform function
            tcode  = self.tcode  # 2-mins, 3-hours, 4-days 
            tsstep = self.tsstep # number of units per step

            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

        # keep up with reach outflow volume

        if 'reach_outvolume' in targets:

            otype  = 'RCHRES'
            group  = 'HYDR'
            var    = 'ROVOL'
            tstype = 'VOL'
            tsform = 1
            idcons = 'ROVOL'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep

            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)        

        # keep up with reach TSS components (daily)

        if 'reach_tss' in targets:

            otype  = 'RCHRES'
            group  = 'SEDTRN'
            var    = 'SSED'
            tstype = 'CONC'
            tsform = 1
            func   = 'AVER'
            tcode  = 4
            tsstep = 1

            # for this one need to change the subscripts from the default
            # total: sub1 = 4

            idcons = 'TSS'

            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep, sub1 = 4)
            lines = lines + new
            n    += len(new)

        if 'reach_total_sediment' in targets:

            otype  = 'RCHRES'
            group  = 'SEDTRN'
            var    = 'RSED'
            tstype = 'CONC'
            tsform = 1
            func   = 'AVER'
            tcode  = 4
            tsstep = 1

            # for this one need to change the subscripts from the default
            # total (bed + water column): sub1 = 10

            idcons = 'RSED'

            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep, sub1 = 10)
            lines = lines + new
            n    += len(new)

        if 'reach_solids' in targets:

            otype  = 'RCHRES'
            group  = 'SEDTRN'
            var    = 'SSED'
            tstype = 'CONC'
            tsform = 1
            func   = 'AVER'
            tcode  = 4
            tsstep = 1

            # for this one need to change the subscripts from the default
            # sand:  sub1 = 1
            # silt:  sub1 = 2
            # clay:  sub1 = 3
            # total: sub1 = 4

            # for now i have all three separate, using IDCONS to identify
            # which one is which

            idcons = 'SAND'
            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep, sub1 = 1)
            lines = lines + new
            n    += len(new)

            idcons = 'SILT'
            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep, sub1 = 2)
            lines = lines + new
            n    += len(new)

            idcons = 'CLAY'
            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep, sub1 = 3)
            lines = lines + new
            n    += len(new)

        if 'reach_sediment_in' in targets:

            otype  = 'RCHRES'
            group  = 'SEDTRN'
            var    = 'ISED'
            tstype = 'CONC'
            tsform = 1
            idcons = 'ISED'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep

            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep, sub1 = 4)
            lines = lines + new
            n    += len(new)

        if 'reach_sediment_out' in targets:

            otype  = 'RCHRES'
            group  = 'SEDTRN'
            var    = 'ROSED'
            tstype = 'CONC'
            tsform = 1
            idcons = 'ROSED'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep

            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep, sub1 = 4)
            lines = lines + new
            n    += len(new)

        if 'shear' in targets:

            otype  = 'RCHRES'
            group  = 'HYDR'
            var    = 'TAU'
            tsform = 1
            tstype = 'TAU'
            idcons = 'TAU'
            func   = 'AVER'
            tcode  = 4
            tsstep = 1

            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

        # keep up with land segment groundwater recharge

        if 'groundwater' in targets:

            otype  = 'PERLND'
            group  = 'PWATER'
            var    = 'IGWI'
            tsform = 1
            tstype = 'FLOW'
            idcons = 'IGWI'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

        # keep up with land segment evapotranspiration
    
        if 'evaporation' in targets:
    
            otype  = 'PERLND'
            group  = 'PWATER'
            var    = 'TAET'
            tsform = 2
            tstype = 'EVAP'
            idcons = 'TAET'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

            otype  = 'IMPLND'
            group  = 'IWATER'
            var    = 'IMPEV'
            tsform = 2
            tstype = 'EVAP'
            idcons = 'IMPEV'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

        # keep up with moisture supplied (precipitation w/snow adjustment)

        if 'supply' in targets:
    
            otype  = 'PERLND'
            group  = 'PWATER'
            var    = 'SUPY'
            tsform = 2
            tstype = 'SUPY'
            idcons = 'SUPY'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

            otype  = 'IMPLND'
            group  = 'IWATER'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

        # keep up with land segment surface runoff
    
        if 'runoff' in targets:

            # surface runoff

            otype  = 'PERLND'
            group  = 'PWATER'
            var    = 'SURO'
            tsform = 2
            tstype = 'FLOW'
            idcons = 'SURO'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

            # interflow runoff

            var    = 'IFWO'
            idcons = var

            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

            # active groundwater outflow

            var    = 'AGWO'
            idcons = var

            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

            # impervious surface runoff

            otype  = 'IMPLND'
            group  = 'IWATER'
            var    = 'SURO'
            tsform = 2
            tstype = 'FLOW'
            idcons = 'SURO'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

        # land segment temperature (daily)
    
        if 'temperature' in targets:
    
            otype  = 'PERLND'
            group  = 'ATEMP'
            var    = 'AIRTMP'
            tsform = 1
            tstype = 'ATMP'
            idcons = 'AIRT'
            func   = 'AVER'
            tcode  = 4
            tsstep = 1
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            otype  = 'IMPLND'
            group  = 'ATEMP'
            var    = 'AIRTMP'
            tsform = 1
            tstype = 'ATMP'
            idcons = 'AIRT'
            func   = 'AVER'
            tcode  = 4
            tsstep = 1
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

        # keep up with hydrology state variables (daily)
    
        if 'water_state' in targets:
    
            # interception storage
    
            otype  = 'PERLND'
            group  = 'PWATER'
            var    = 'CEPS'
            tsform = 1
            tstype = 'VOL '
            idcons = 'CEPS'
            func   = 'AVER'
            tcode  = 4
            tsstep = 1
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # surface storage
    
            var    = 'SURS'
            idcons = var
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # upper zone storage
    
            var    = 'UZS '
            idcons = var
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # interflow storage
    
            var    = 'IFWS'
            idcons = var
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
            
            # lower zone storage
    
            var    = 'LZS '
            idcons = var
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # active groundwater storage
    
            var    = 'AGWS'
            idcons = var
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
        
            # impervious retention storage
    
            otype  = 'IMPLND'
            group  = 'IWATER'
            var    = 'RETS'
            tstype = 'VOL '
            idcons = var
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious surface storage
    
            var    = 'SURS'
            idcons = var
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # reach volume
    
            otype  = 'RCHRES'
            group  = 'HYDR'
            var    = 'VOL'
            tstype = 'VOL'
            idcons = tstype
    
            new = self.add_ext_targets(self.rchreses, wdm, year, n, otype, 
                                       group, var, tsform, tstype, idcons, func,
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

        # total water stored
    
        if 'water_total' in targets:
    
            otype  = 'PERLND'
            group  = 'PWATER'
            var    = 'PERS'
            tsform = 1
            tstype = 'VOL '
            func   = 'AVER'
            tcode  = 4
            tsstep = 1
            idcons = var
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            otype  = 'IMPLND'
            group  = 'IWATER'
            var    = 'IMPS'
            tsform = 1
            tstype = 'VOL '
            func   = 'AVER'
            tcode  = 4
            tsstep = 1
            idcons = var
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
        # snow state variables (water equivalent depth)
    
        if 'snow_state' in targets:
    
            # snow + ice water equivalent depth
    
            otype  = 'PERLND'
            group  = 'SNOW'
            var    = 'PACKF'
            tsform = 1
            tstype = 'PACKF'
            idcons = 'PACKF'
            func   = 'AVER'
            tcode  = 4
            tsstep = 1
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep) 
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # pack ice (water equivalent)
    
            otype  = 'PERLND'
            var    = 'PACKI'
            tstype = var
            idcons = var
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # pack water (water equivalent depth)
    
            otype  = 'PERLND'
            var    = 'PACKW'
            tstype = var
            idcons = var
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
        # land segment snow pack depth (water equivalent depth)
    
        if 'snowdepth' in targets:
    
            otype  = 'PERLND'
            group  = 'SNOW'
            var    = 'PACK'
            tsform = 1
            tstype = 'PACK'
            idcons = 'PACK'
            func   = 'AVER'
            tcode  = 4
            tsstep = 1
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
        # land segment snow pack depth (real depth)
    
        if 'snowpack' in targets:
    
            otype  = 'PERLND'
            group  = 'SNOW'
            var    = 'PDEPTH'
            tsform = 1
            tstype = 'PDEP'
            idcons = 'PDEP'
            func   = 'AVER'
            tcode  = 4
            tsstep = 1
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, tcode,
                                       tsstep)
            lines = lines + new
            n    += len(new)

        # land segment snow fall depth (real depth)
    
        if 'snowfall' in targets:

            otype  = 'PERLND'
            group  = 'SNOW'
            var    = 'SNOWF'
            tsform = 2
            tstype = 'SNOF'
            idcons = 'SNOF'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, tcode,
                                       tsstep)
            lines = lines + new
            n    += len(new)

        # land segment snow melt yield
    
        if 'snowmelt' in targets:
    
            otype  = 'PERLND'
            group  = 'SNOW'
            var    = 'WYIELD'
            tsform = 2
            tstype = 'WYIE'
            idcons = 'WYIE'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

        # land segment snow cover fraction
    
        if 'snowcover' in targets:
    
            otype  = 'PERLND'
            group  = 'SNOW'
            var    = 'SNOCOV'
            tsform = 1
            tstype = 'SCOV'
            idcons = 'SCOV'
            func   = 'AVER'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, tcode,
                                       tsstep)
            lines = lines + new
            n    += len(new)
   
        if 'rain' in targets:
 
            otype  = 'PERLND'
            group  = 'SNOW'
            var    = 'RAINF'
            tsform = 1
            tstype = 'RAIN'
            idcons = 'RAIN'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, tcode,
                                       tsstep)
            lines = lines + new
            n    += len(new)

        if 'ice' in targets:
 
            otype  = 'PERLND'
            group  = 'SNOW'
            var    = 'PACKI'
            tsform = 1
            tstype = 'ICE'
            idcons = 'ICE'
            func   = 'AVER'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, tcode,
                                       tsstep)
            lines = lines + new
            n    += len(new)

        # keep up with land segment surface runoff
    
        if 'erosion' in targets:

            # pervious erosion

            otype  = 'PERLND'
            group  = 'SEDMNT'
            var    = 'SOSED'
            tsform = 2
            tstype = 'SOSED'
            idcons = 'SOSED'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

            # impervious erosion

            otype  = 'IMPLND'
            group  = 'SOLIDS'
            var    = 'SOSLD'
            tsform = 2
            tstype = 'SOSLD'
            idcons = 'SOSLD'
            func   = 'SAME'
            tcode  = self.tcode
            tsstep = self.tsstep
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)

        # land segment detached sediment
    
        if 'detached_sediment' in targets:
    
            otype  = 'PERLND'
            group  = 'SEDMNT'
            var    = 'DETS'
            tsform = 1
            tstype = 'DETS'
            idcons = 'DETS'
            func   = 'AVER'
            tcode  = 4
            tsstep = 1
    
            new = self.add_ext_targets(self.perlnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, 
                                       tcode, tsstep)
            lines = lines + new
            n    += len(new)
    
            # impervious
    
            otype  = 'IMPLND'
            group  = 'SOLIDS'
            var    = 'SLDS'
            tsform = 1
            tstype = 'SLDS'
            idcons = 'SLDS'
            func   = 'AVER'
            tcode  = 4
            tsstep = 1
    
            new = self.add_ext_targets(self.implnds, wdm, year, n, otype, group,
                                       var, tsform, tstype, idcons, func, tcode,
                                       tsstep)
            lines = lines + new
            n    += len(new)

        # close the wdmeditor

        wdm.close(self.wdmoutfile)
        wdm.close_message()
    
        # finish up 
    
        lines = lines + ['END EXT TARGETS', '']
    
        return lines

    def time_format(self, date, end = False):
        """Takes an instance of datetime.datetime class and returns a date and 
        time as a string compatible with HSPF."""

        if end and date.hour == 0:
            date = date + datetime.timedelta(days = -1)

        h = date.strftime('%H')
        m = date.strftime('%M')

        yr = date.strftime('%Y')
        mo = date.strftime('%m')
        da = date.strftime('%d')

        return ('%s/%s/%s %s:%s' % (yr, mo, da, h, m))

    def format_tstep(self):
        """Takes a time step in minutes and formats it to HH:MM"""

        hours   = self.tstep // 60
        minutes = self.tstep - 60 * hours

        return ('%02d:%02d' % (hours, minutes))

    def global_block(self, run_flag, start, end):
        """Makes the "GLOBAL" block of the UCI file for HSPF."""

        if   self.units == 'English': u = 1
        elif self.units == 'Metric':  u = 2
        
        return  ['GLOBAL',
                 '  UCI created by HSPpy for %s at %s' % 
                 (self.description, str(datetime.datetime.now())[:-10]),
                 '  START       %s  END    %s' % 
                 (self.time_format(start), 
                  self.time_format(end, end = True)),
                 '  RUN INTERP OUTPT LEVELS    %d    %d' % 
                 (self.outlev, self.spout),
                 ('  RESUME     0 RUN     %d' % run_flag +
                  '                    UNIT SYSTEM    %d  IHM    0' % u),
                 'END GLOBAL', '']

    def files_block(self):
        """Makes the "FILES" block of the UCI file for HSPF."""

        lines = ['FILES',
                 '<FILE>  <UN#>***<----FILE NAME-----------------' + 
                 '-------------------------------->']
    
        for ftype, funit, fname in zip(self.ftypes, self.funits, self.fnames):
            lines.append('{0:<6}  {1:>5}   {2:<62}'.format(ftype, funit, fname))
            
        lines = lines + ['END FILES', '']

        return lines

    def opn_sequence_block(self):
        """Makes the "OPN SEQUENCE" block of the UCI file for HSPF."""

        lines = ['OPN SEQUENCE',
                 '    INGRP              INDELT ' + self.format_tstep()]

        for perlnd in self.perlnds:
            lines.append('      PERLND     %3d' % perlnd.operation)
             
        for implnd in self.implnds:
            lines.append('      IMPLND     %3d' % implnd.operation)
             
        for rchres in self.rchreses:
            lines.append('      RCHRES     %3d' % rchres.operation)

        lines = lines + ['    END INGRP', 'END OPN SEQUENCE', '']

        return lines

    def bin(self, activity):
        """Returns 1 if active or 0 otherwise."""

        if activity: return 1
        else:        return 0

    def perlnd_block(self, hydrology = False, temp = False, snow = False, 
                     sediment = False):
        """Makes the "PERLND" block of the UCI file for HSPF. Note that 
        this block is not complete as there are many optional blocks for 
        PERLND. Updating should be relatively simple."""

        output_interval = 1

        # add the flags for the modules

        lines = ['PERLND',
                 '  ACTIVITY',
                 '*** <PLS >               Active Sections' + 
                 '                               ***',
                 '*** x -  x ATMP SNOW PWAT  SED  PST  PWG ' +
                 'PQAL MSTL PEST NITR PHOS TRAC ***']

        for p in self.perlnds:

            # convert flags to 1/0

            flags = (p.ATMP, p.SNOW, p.PWAT, p.SED, p.PST, p.PWG, p.PQAL, 
                     p.MSTL, p.PEST, p.NITR, p.PHOS, p.TRAC)

            lines.append('%5d%10d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d' % 
                         ((p.operation,) + tuple(self.bin(f) for f in flags)))

        lines = lines + ['  END ACTIVITY', '']

        # make the print line; see the HSPF instructions for more info
        # on the print output level if changes are desired

        if self.print_file is not None:

            lines = lines + ['  PRINT-INFO',
                             '*** < PLS>' + 23 * ' ' + 'Print-flags' + 27 * 
                             ' ' + 'PIVL  PYR',
                             '*** x  - x ATMP SNOW PWAT  SED  PST  PWG PQAL ' + 
                             'MSTL PEST NITR PHOS TRAC']

            for p in self.perlnds:
                
                lines.append('%5d%10d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d' %
                             ((p.operation,) + 
                              tuple(self.print_level for i in range(12)) +
                              (output_interval, 12)))

            lines = lines + ['  END PRINT-INFO', '']

        # add the binary info line

        if self.binary_file is not None:

            lines = lines + ['  BINARY-INFO',
                             '*** < PLS>' + 15 * ' ' + 'Binary Output Flags' + 
                             27 * ' ' + 'BIVL  BYR',
                             '*** x  - x ATMP SNOW PWAT  SED  PST  PWG ' +
                             'PQAL MSTL PEST NITR PHOS TRAC']

            for p in self.perlnds:
                
                lines.append('%5d%10d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d' %
                             ((p.operation,) + 
                              (self.print_level for i in range(12)) +
                              (output_interval, 12)))

            lines = lines + ['  END BINARY-INFO', '']

        # add the general info line

        lines = lines + ['  GEN-INFO',
                         '***             Name' + 18 * ' ' + 
                         'Unit-systems   Printer BinaryOut',
                         '*** <PLS >' + 32 * ' ' + 
                         't-series Engl Metr Engl Metr',
                         '*** x -  x                                 ' +
                         'in  out']

        if self.print_file is not None:  pf = self.print_no
        else:                            pf = 0

        if self.binary_file is not None: b  = self.binary_no
        else:                            b  = 0

        if   self.units == 'English': 
            ot = (pf, 0, b, 0)
            u  = 1
        elif self.units == 'Metric':  
            ot = (0, pf, 0, b)
            u  = 2

        for p in self.perlnds:        

            description = '{} {}'.format(p.comid, p.landtype)

            line = ('{0:>5}     {1:<21}'.format(p.operation, description[:20]) +
                    '             %d    %d' % (u, u) +
                    '{0:>5}{1:>5}{2:>5}{3:>5}'.format(*ot))
            lines.append(line)

        lines = lines + ['  END GEN-INFO', '']

        # add pwater (if simulating hydrology)

        if hydrology:

            # add the flags for pwater

            lines = lines + ['  PWAT-PARM1',
                             '*** <PLS >                   Flags',
                             '*** x -  x CSNO RTOP UZFG  VCS  VUZ  VNN VIFW ' + 
                             'VIRC  VLE IFFC  HWT IRRG']

            for p in self.perlnds:

                lines.append('%5d%10d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d' % 
                             p.get_pwat_parm1())

            lines = lines + ['  END PWAT-PARM1', '']

            # add the infiltration/overland flow parameters

            lines = lines + ['  PWAT-PARM2',
                             '*** < PLS>    FOREST      LZSN    INFILT      ' +
                             'LSUR     SLSUR     KVARY     AGWRC']

            if self.units == 'English':

                lines = lines + ['*** x  - x                (in)   (in/hr)' + 
                                 '      (ft)              (1/in)   (1/day)']

            elif self.units == 'Metric':
                
                lines = lines + ['*** x  - x                (mm)   (mm/hr)' + 
                                 '       (m)              (1/mm)   (1/day)']

            for p in self.perlnds:

                #N, FOREST, LZSN, INFILT, LSUR, SLSUR, KVARY, AGWRC

                parms = p.get_pwat_parm2()

                lines.append('%5d%15.3f%10.2f%10.4f%10.1f%10.6f%10.3f%10.3f' % 
                             parms)

            lines = lines + ['  END PWAT-PARM2', '']

            # add the evapotranspiration parameters

            lines = lines + ['  PWAT-PARM3',
                             '*** < PLS>    PETMAX    PETMIN    INFEXP    ' +
                             'INFILD    DEEPFR    BASETP    AGWETP']

            if self.units == 'English':

                lines = lines + ['*** x  - x   (deg F)   (deg F)']

            elif self.units == 'Metric':

                lines = lines + ['*** x  - x   (deg C)   (deg C)']

            for p in self.perlnds:

                parms = p.get_pwat_parm3()

                # N, PETMAX, PETMIN, INFEXP, INFILD, DEEPFR, BASETP, AGWETP

                lines.append('%5d%15.1f%10.1f%10.2f%10.2f%10.2f%10.2f%10.2f' % 
                             parms)

            lines = lines + ['  END PWAT-PARM3', '']

            # PWAT-PARM4 upper zone

            lines = lines + ['  PWAT-PARM4',
                             '*** <PLS >     CEPSC      UZSN      NSUR' +
                             '     INTFW       IRC     LZETP']

            if self.units == 'English':

                lines = lines + ['*** x -  x      (in)      (in)' +
                                 '                       (1/day)']

            elif self.units == 'Metric':

                lines = lines + ['*** x -  x      (mm)      (mm)' +
                                 '                       (1/day)']

            for p in self.perlnds:

                # N, CEPSC, UZSN, NSUR, INTFW, IRC, LZETP

                parms = p.get_pwat_parm4()

                lines.append('%5d%15.4f%10.4f%10.4f%10.4f%10.6f%10.4f' %
                             parms)

            lines = lines + ['  END PWAT-PARM4', '']

            # add the PWAT-PARM5 lines

            lines = lines + ['  PWAT-PARM5',
                             '*** <PLS>                 ' +
                             '                                            ***',
                             '*** x -  x       FZG      FZGL']

            for p in self.perlnds: 
                lines.append('%5d%15d%10d' % p.get_pwat_parm5())

            lines = lines + ['  END PWAT-PARM5', '']

            # add the PWAT-PARM6 lines if needed

            lines = lines + ['  PWAT-PARM6',
                             '*** x -  x     MELEV      BELV    GWDATM       ' +
                             'PCW       PGW      UPGW']

            if self.units == 'English':

                lines = lines + ['***             (ft)      (ft)      (ft)']

            elif self.units == 'Metric':

                lines = lines + ['***              (m)       (m)       (m)']

            for p in self.perlnds: 
                lines.append('%5d%15d%10d%10d%10.3f%10.3f%10.3f' %
                             p.get_pwat_parm6())

            lines = lines + ['  END PWAT-PARM6', '']

            # add the PWAT-PARM7 lines if needed

            lines = lines + ['  PWAT-PARM7',
                             '*** x -  x    STABNO      SRRC     SREXP     ' +
                             'IFWSC     DELTA    UELFAC    LELFAC']

            if self.units == 'English':

                lines = lines + ['***                      (/hr)' +
                                 '                (in)      (in)']

            elif self.units == 'Metric':

                lines = lines + ['***                      (/hr)' +
                                 '                (mm)      (mm)']

            for p in self.perlnds: 
                lines.append('%5d%15d%10.3f%10.3f%10.3f%10.3f%10.2f%10.2f' %
                             p.get_pwat_parm7())

            lines = lines + ['  END PWAT-PARM7', '']

            # add the state variable initial values

            if   self.units == 'English': u = '(in)'
            elif self.units == 'Metric':  u = '(mm)'
                
            lines = lines + ['  PWAT-STATE1',
                             '*** < PLS>  PWATER state variables {}'.format(u),
                             '*** x  - x      CEPS      SURS       UZS  ' +
                             '    IFWS       LZS      AGWS      GWVS']

            for p in self.perlnds:
                lines.append('%5d%15.4f%10.4f%10.4f%10.4f%10.4f%10.4f%10.4f' % 
                             p.get_pwat_state())

            lines = lines + ['  END PWAT-STATE1', '']

            # add the monthly variable parameters if needed

            mon_names =['INTERCEP', 'UZSN', 'MANNING', 'INTERFLW','IRC',
                        'LZETPARM']
            mon_descs =['Interception storage capacity at start of each ' +
                        'month {}'.format(u),
                        'Upper zone storage at start of each month {}'.format(u),
                        'Mannings n at start of each month',
                        'Interflow inflow parameter for start of each month',
                        'Interflow recession constant at start of each month',
                        'Lower zone evapotranspiration parameter at start ' +
                        'of each month']

            # add the monthly varible parameters that are constant if needed

            VCSs  = [p.VCS  == 0 for p in self.perlnds] # interception
            VUZs  = [p.VUZ  == 0 for p in self.perlnds] # upper zone
            VNNs  = [p.VNN  == 0 for p in self.perlnds] # manning's n
            VIFWs = [p.VIFW == 0 for p in self.perlnds] # interflow infiltration
            VIRCs = [p.VIRC == 0 for p in self.perlnds] # interflow recession
            VLEs  = [p.VLE  == 0 for p in self.perlnds] # lower zone ET

            mon_flags = [VCSs, VUZs, VNNs, VIFWs, VIRCs, VLEs]
            p_flags   = [any(f) for f in 
                         zip(VCSs, VUZs, VNNs, VIFWs, VIRCs, VLEs)]

            for pflags, name, desc in zip(mon_flags, mon_names, mon_descs):

                if any([not f for f in pflags]): # monthly variable

                    lines = lines + ['  MON-' + name,
                                     '*** <PLS >  ' + desc,
                                     '*** x -  x  JAN  FEB  MAR  APR  MAY  ' +
                                     'JUN  JUL  AUG  SEP  OCT  NOV  DEC']

                    for p, flag in zip(self.perlnds, pflags):
                
                        if not flag and name != 'UZSN':

                            values = tuple(p.get_monthly(name))
                            lines.append('%5d' % p.operation +
                                         '%10.2f%5.2f%5.2f%5.2f' % values[:4]  +
                                         '%5.2f%5.2f%5.2f%5.2f'  % values[4:8] +
                                         '%5.2f%5.2f%5.2f%5.2f'  % values[8:])

                        elif not flag:

                            values = tuple(p.get_monthly(name))
                            lines.append('%5d' % p.operation +
                                         '%10.1f%5.1f%5.1f%5.1f' % values[:4]  +
                                         '%5.1f%5.1f%5.1f%5.1f'  % values[4:8] +
                                         '%5.1f%5.1f%5.1f%5.1f'  % values[8:])

                    lines = lines + ['  END MON-' +  name, '']

        # add the temp (if needed)

        if temp:

            lines = lines + ['  ATEMP-DAT', '*** <PLS >     ELDAT    AIRTEMP']

            if self.units == 'English': 
                lines.append('*** x -  x      (ft)    (deg F)')
            if self.units == 'Metric': 
                lines.append('*** x -  x       (m)    (deg C)')

            for p in self.perlnds: 
                lines.append('%5d%15.1f%10.1f' % p.get_atemp_dat())

            lines = lines + ['  END ATEMP-DAT', '']

        # add the snow (if needed)

        if snow:

            lines = lines + ['  ICE-FLAG', '*** <PLS > Ice-', '*** x -  x flag']

            for p in self.perlnds: lines.append('%5d%10d' % 
                                                p.get_ice_flag())

            lines = lines + ['  END ICE-FLAG', '', '  SNOW-FLAGS']

            for p in self.perlnds: 
                lines.append('%5d%10d%5d' % p.get_snow_flags())

            lines = lines + ['  END SNOW-FLAGS',
                             '',
                             '  SNOW-PARM1',
                             '*** < PLS>       LAT     MELEV     SHADE    ' +
                             'SNOWCF    COVIND     KMELT     TBASE',
                             '*** x  - x   degrees       (m)              ' +
                             '            (mm)  (mm/d.C)       (C)']

            for p in self.perlnds: 
                
                # N, LAT, MELEV, SHADE, SNOWCF, COVIND, KMELT, TBASE

                parms = p.get_snow_parm1()

                lines.append('%5d%15.2f%10.1f%10.3f%10.3f%10.1f%10.1f%10.1f' % 
                             parms)

            lines = lines + ['  END SNOW-PARM1',
                             '',
                             '  SNOW-PARM2',
                             '*** <PLS >     RDCSN     TSNOW    SNOEVP    ' +
                             'CCFACT    MWATER    MGMELT',
                             '*** x -  x             (deg C)              ' +
                             '                  (mm/day)']

            for p in self.perlnds: 
                lines.append('%5d%15.3f%10.1f%10.3f%10.2f%10.3f%10.3f' % 
                             p.get_snow_parm2())

            lines = lines + ['  END SNOW-PARM2',
                             '',
                             '  SNOW-INIT1',
                             '*** <PLS > Pack-snow  Pack-ice Pack-watr    ' +
                             'RDENPF      DULL    PAKTMP',
                             '*** x -  x      (mm)      (mm)      (mm)    ' +
                             '                   (deg C)']

            for p in self.perlnds: 
                lines.append('%5d%15.2f%10.2f%10.2f%10.2f%10.1f%10.1f' % 
                             p.get_snow_init1())

            lines = lines + ['  END SNOW-INIT1',
                             '',
                             '  SNOW-INIT2',
                             '*** <PLS >    COVINX    XLNMLT    SKYCLR',
                             '*** x -  x      (mm)      (mm)']

            for p in self.perlnds: 
                lines.append('%5d%15.1f%10.1f%10.3f' % 
                             p.get_snow_init2())

            lines = lines + ['  END SNOW-INIT2', '']

        # add the sediment transport

        if sediment:

            lines = lines + ['  SED-PARM1',
                             '*** <PLS >  Sediment parameters 1',
                             '*** x -  x  CRV VSIV SDOP']

            for p in self.perlnds: 
                lines.append('%5d%10d%5d%5d' % p.get_sed_parm1())

            lines = lines + ['  END SED-PARM1',
                             '',
                             '  SED-PARM2',
                             '*** <PLS >      SMPF      KRER      JRER     ' +
                             'AFFIX     COVER      NVSI',
                             '***            (/day)           (kg/ha.dy)']

            for p in self.perlnds: 
                lines.append('%5d%15.2f%10.3f%10.1f%10.3f%10.1f%10.1f'
                             % p.get_sed_parm2())
                         
            lines = lines + ['  END SED-PARM2',
                             '',
                             '  SED-PARM3',
                             '*** <PLS >  Sediment parameter 3',
                             '*** x -  x      KSER      JSER      KGER      ' +
                             'JGER']

            for p in self.perlnds: 
                lines.append('%5d%15.3f%10.2f%10.2f%10.2f' % p.get_sed_parm3())

            lines = lines + ['  END SED-PARM3', '']

#
# need to add monthly flag section, for now omitted
#

            lines = lines + ['  SED-STOR',
                             '*** <PLS >  Detached sediment storage (tonne/ha)',
                             '*** x -  x      DETS']

            for p in self.perlnds: lines.append('%5d%15.3f' % p.get_sed_stor())

            lines = lines + ['  END SED-STOR', '']

        lines = lines[:-1] + ['END PERLND', '']

        return lines

    def implnd_block(self, hydrology = True, temp = False, snow = False, 
                     sediment = False):
        """Adds the block of lines for the implnds to a UCI file."""

        output_interval = 1

        # add activity flags

        lines = ['IMPLND',
                 '  ACTIVITY',
                 '*** <ILS >               Active Sections',
                 '*** x -  x ATMP SNOW IWAT  SLD  IWG IQAL']

        for i in self.implnds:

            flags = [temp, snow, hydrology, sediment, i.IWG, i.IQAL]
            
            lines.append('%5d%10d%5d%5d%5d%5d%5d' % 
                         ((i.operation,) + tuple(self.bin(f) for f in flags)))

        lines = lines + ['  END ACTIVITY', '']

        # add print/binary output flags

        if self.units == 'English':  u = 1
        elif self.units == 'Metric': u = 2

        if self.print_file is not None:

            lines = lines + ['  PRINT-INFO', 
                             '*** <ILS > ******** Print-flags ******** PIVL' +
                             '  PYR',
                             '*** x -  x ATMP SNOW IWAT  SLD  IWG IQAL ' +
                             '*********']

            for i in self.implnds:

                flags = ((i.operation,) + 
                         tuple([self.print_level for i in range(6)]) + 
                         (output_interval, 12))
                lines.append('%5d%10d%5d%5d%5d%5d%5d%5d%5d' % flags)

            lines = lines + ['  END PRINT-INFO', '']

        if self.binary_file is not None:

            lines = lines + ['  BINARY-INFO',
                             '*** <ILS > **** Binary-Output-flags **** BIVL' +
                             '  BYR',
                             '*** x -  x ATMP SNOW IWAT  SLD  IWG IQAL ' +
                             '*********']
        
            for i in self.implnds:

                lines.append('%5d%10d%5d%5d%5d%5d%5d%5d%5d' % 
                             (i.operation, 2, 2, 2, 2, 2, 2,output_interval,12))

            lines = lines + ['  END BINARY-INFO', '']

        # add the GEN-INFO

        lines = lines + ['  GEN-INFO',
                         '***             Name             Unit-systems' +
                         '   Printer BinaryOut',
                         '*** <ILS >                           t-series ' +
                         'Engl Metr Engl Metr',
                         '*** x -  x                            in  out']

        if self.print_file is not None:  pf = self.print_no
        else:                            pf = 0

        if self.binary_file is not None: b  = self.binary_no
        else:                            b  = 0

        if   self.units == 'English': t = pf, 0, b, 0
        elif self.units == 'Metric':  t = 0, pf, 0, b

        for i in self.implnds:

            description = '{} impervious'.format(i.comid)

            line = ('{0:>5}     {1:<21}'.format(i.operation, description) +
                    '        %d    %d' % (u, u) +
                    '{0:>5}{1:>5}{2:>5}{3:>5}'.format(*t))
            lines.append(line)

        lines = lines + ['  END GEN-INFO', '']

        # add iwater (if needed)

        if hydrology:

            # add the iwat-parm1 block

            lines = lines + ['  IWAT-PARM1',
                             '*** <ILS >        Flags',
                             '*** x -  x CSNO RTOP  VRS  VNN RTLI']

            for i in self.implnds: 
                lines.append('%5d%10d%5d%5d%5d%5d' % i.get_iwat_parm1())

            lines = lines + ['  END IWAT-PARM1', '']

            # add the iwat-parm2 block

            lines = lines + ['  IWAT-PARM2',
                             '*** <ILS >      LSUR     SLSUR      NSUR     ' +
                             'RETSC']

            if self.units == 'English':

                lines = lines + ['*** x -  x      (ft)                     ' +
                                 '     (in)']

            elif self.units == 'Metric':

                lines = lines + ['*** x -  x       (m)                     ' +
                                 '     (mm)']

            for i in self.implnds: 
                lines.append('%5d%15.2f%10.5f%10.5f%10.2f' % i.get_iwat_parm2())

            lines = lines + ['  END IWAT-PARM2', '']

            # add the iwat-parm3 block

            if   self.units == 'English':

                lines = lines + ['  IWAT-PARM3',
                                 '*** <ILS >    PETMAX    PETMIN',
                                 '*** x -  x   (deg F)   (deg F)']

            elif self.units == 'Metric':

                lines = lines + ['  IWAT-PARM3',
                                 '*** <ILS >    PETMAX    PETMIN',
                                 '*** x -  x   (deg C)   (deg C)']

            for i in self.implnds: 
                lines.append('%5d%15.1f%10.1f' % i.get_iwat_parm3())

            lines = lines + ['  END IWAT-PARM3', '']

            # add the initial values of the state variables

            if self.units == 'English':

                lines = lines + ['  IWAT-STATE1',
                                 '*** <ILS >  IWATER state variables (in)',
                                 '*** x -  x      RETS      SURS']

            if self.units == 'Metric':

                lines = lines + ['  IWAT-STATE1',
                                 '*** <ILS >  IWATER state variables (mm)',
                                 '*** x -  x      RETS      SURS']

            for i in self.implnds: 
                lines.append('%5d%15.3f%10.3f' % i.get_iwat_state1())

            lines = lines + ['  END IWAT-STATE1', '']

        # add the temp (if needed)

        if temp:

            lines = lines + ['  ATEMP-DAT',
                             '*** <PLS >     ELDAT    AIRTEMP']

            if self.units == 'English': 
                lines.append('*** x -  x      (ft)    (deg F)')
            if self.units == 'Metric': 
                lines.append('*** x -  x       (m)    (deg C)')

            for i in self.implnds: 
                lines.append('%5d%15.1f%10.1f' % tuple(i.get_atemp_dat()))

            lines = lines + ['  END ATEMP-DAT', '']

        # add the snow (if needed)

        if snow:

            lines = lines + ['  ICE-FLAG', '*** <PLS > Ice-', '*** x -  x flag']

            for i in self.implnds: lines.append('%5d%10d' % 
                                                tuple(i.get_ice_flag()))

            lines = lines + ['  END ICE-FLAG', '', '  SNOW-FLAGS']

            for i in self.implnds: 
                lines.append('%5d%10d%5d' % tuple(i.get_snow_flags()))

            lines = lines + ['  END SNOW-FLAGS',
                             '',
                             '  SNOW-PARM1',
                             '*** < PLS>       LAT     MELEV     SHADE    ' +
                             'SNOWCF    COVIND     KMELT     TBASE',
                             '*** x  - x   degrees       (m)              ' +
                             '            (mm)  (mm/d.C)       (C)']

            for i in self.implnds: 
                lines.append('%5d%15.2f%10.1f%10.3f%10.3f%10.1f%10.1f%10.1f' % 
                             tuple(i.get_snow_parm1()))

            lines = lines + ['  END SNOW-PARM1',
                             '',
                             '  SNOW-PARM2',
                             '*** <PLS >     RDCSN     TSNOW    SNOEVP    ' +
                             'CCFACT    MWATER    MGMELT',
                             '*** x -  x             (deg C)              ' +
                             '                  (mm/day)']

            for i in self.implnds: 
                lines.append('%5d%15.3f%10.1f%10.3f%10.2f%10.3f%10.3f' % 
                             tuple(i.get_snow_parm2()))

            lines = lines + ['  END SNOW-PARM2',
                             '',
                             '  SNOW-INIT1',
                             '*** <PLS > Pack-snow  Pack-ice Pack-watr    ' +
                             'RDENPF      DULL    PAKTMP',
                             '*** x -  x      (mm)      (mm)      (mm)    ' +
                             '                   (deg C)']

            for i in self.implnds: 
                lines.append('%5d%15.2f%10.2f%10.2f%10.2f%10.1f%10.1f' % 
                             tuple(i.get_snow_init1()))

            lines = lines + ['  END SNOW-INIT1',
                             '',
                             '  SNOW-INIT2',
                             '*** <PLS >    COVINX    XLNMLT    SKYCLR',
                             '*** x -  x      (mm)      (mm)']

            for i in self.implnds: 
                lines.append('%5d%15.1f%10.1f%10.3f' % 
                             tuple(i.get_snow_init2()))

            lines = lines + ['  END SNOW-INIT2', '']

        # add the sediment transport

        if sediment:

            lines = lines + ['  SLD-PARM1',
                             '*** <ILS >     Flags',
                             '*** x -  x VASD VRSD SDOP']

            for i in self.implnds: 
                lines.append('%5d%10d%5d%5d' % i.get_sld_parm1())

            lines = lines + ['  END SLD-PARM1',
                             '',
                             '  SLD-PARM2',
                             '***             KEIM      JEIM    ACCSDP    ' +
                             'REMSDP',
                             '*** <ILS >                    (tne/ha.d)    ' +
                             '(/day)',
                             '*** x -  x']

            for i in self.implnds: 
                lines.append('%5d%15.3f%10.3f%10.4f%10.3f' % i.get_sld_parm2())
        
            lines = lines + ['  END SLD-PARM2',
                             '',
                             '  SLD-STOR',
                             '*** <ILS >  Solids storage (tonne/ha)',
                             '*** x -  x']

            for i in self.implnds: lines.append('%5d%15.3f' % i.get_sld_stor())

            lines = lines + ['  END SLD-STOR', '']

        # finish up

        lines = lines[:-1] + ['END IMPLND', '']

        return lines

    def rchres_block(self, hydrology = False, sediment = False):
        """Adds the block of lines for the reaches for HSPF to a UCI file."""

        output_interval = 1
        lines = ['RCHRES',
                 '  ACTIVITY',
                 '*** RCHRES  Active sections',
                 '*** x -  x HYFG ADFG CNFG HTFG SDFG GQFG OXFG NUFG PKFG PHFG']

        for r in self.rchreses:

            if any([r.CNFG, r.HTFG, r.SDFG, r.GQFG, r.OXFG, r.NUFG, r.PKFG, 
                    r.PKFG, r.PHFG]): 
                r.ADFG = True

            flags =  [r.HYFG, r.ADFG, r.CNFG, r.HTFG, r.SDFG, r.GQFG, 
                      r.OXFG, r.NUFG, r.PKFG, r.PHFG]

            lines.append('%5d%10d%5d%5d%5d%5d%5d%5d%5d%5d%5d' % 
                         ((r.operation,) + tuple(self.bin(f) for f in flags)))

        lines = lines + ['  END ACTIVITY', '']

        if self.print_file is not None:  pf = self.print_no
        else:                            pf = 0

        if self.binary_file is not None: b  = self.binary_no
        else:                            b  = 0

        if self.print_file is not None:

            lines = lines + ['  PRINT-INFO',
                             '*** RCHRES  Printout level flags',
                             '*** x -  x HYDR ADCA CONS HEAT  SED  GQL ' +
                             'OXRX NUTR PLNK PHCB PIVL  PYR']
                     
            for r in self.rchreses:

                lines.append('%5d%10d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d' % 
                             ((r.operation,) + 
                              tuple(self.print_level for i in range(10)) +
                              (output_interval, 12)))

            lines = lines + ['  END PRINT-INFO', '']

        if self.binary_file is not None:

            lines = lines + ['  BINARY-INFO',
                             '*** RCHRES  Binaryout level flags',
                             '*** x -  x HYDR ADCA CONS HEAT  SED  GQL ' +
                             'OXRX NUTR PLNK PHCB PIVL  PYR']

            for r in self.rchreses:

                lines.append('%5d%10d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d%5d' % 
                             ((r.operation,) + tuple(2 for i in range(10)) +
                              (output_interval, 12)))

            lines = lines + ['  END BINARY-INFO', '']

        lines = lines + ['  GEN-INFO',
                         '***              Name        Nexits   Unit Systems' +
                         '   Printer      BinaryOut',
                         '*** RCHRES                               t-series' +
                         '  Engl Metr LKFG Engl Metr',
                         '*** x -  x                                 in  out']

        for r in self.rchreses:

            description = '{0} {1}'.format(r.comid, r.gnis)[:20]

            if self.print_file is None:  pf = 0
            else:                        pf = self.print_no

            if self.binary_file is None: b  = 0
            else:                        b  = self.binary_no

            if r.lake: l = 1
            else:      l = 0

            if   self.units == 'English': t = r.nexits, 1, 1, pf, 0, l, b, 0
            elif self.units == 'Metric':  t = r.nexits, 2, 2, 0, pf, l, 0, b

            line = ('{0:>5}     {1:<20}'.format(r.operation, description) +
                    '%5d%10d%5d%5d%5d%5d%5d%5d' % t)
            lines.append(line)

        lines = lines + ['  END GEN-INFO', '']

        # add the HYDR-PARM1 block

        lines = lines + ['  HYDR-PARM1',
                         '***         Flags for HYDR section',
                         '***RC HRES  VC A1 A2 A3  ODFVFG for each *** ' +
                         'ODGTFG for each     FUNCT  for each',
                         '*** x  - x  FG FG FG FG  possible   exit *** ' + 
                         'possible   exit     possible   exit'
                         ]

        for r in self.rchreses:

            vs = r.get_hydr_parm1()
            lines.append('%5d%9d%3d%3d%3d%5d%3d%3d%3d%3d%8d' % vs[:11] +
                         '%3d%3d%3d%3d%8d%3d%3d%3d%3d' % vs[11:])

        lines = lines + ['  END HYDR-PARM1', '']

        # add the HYDR-PARM2 block

        lines = lines + ['  HYDR-PARM2',
                         '*** RCHRES FDSN FTBN       LEN     DELTH     STCOR' +
                         '        KS      DB50']

        if self.units == 'English':

            lines.append('*** x -  x                (mi)      (ft)      (ft)' +
                         '                (in)')

        elif self.units == 'Metric':
            
            lines.append('*** x -  x                (km)       (m)       (m)' +
                         '                (mm)')
                    
        for r in self.rchreses:

            lines.append('%5d%10d%5d%10.2f%10.2f%10.2f%10.2f%10.2f' % 
                         r.get_hydr_parm2())

        lines = lines + ['  END HYDR-PARM2', '']

        # add the HYDR-INIT block

        lines = lines + ['  HYDR-INIT',
                         '***         Initial conditions for HYDR section',
                         '***RCHRES        VOL  CAT Initial value  of COLIND' +
                         '     initial  value  of OUTDGT']

        if self.units == 'English':

            lines.append('*** x  - x     ac-ft      for each possible   exit' +
                         '    for each possible exit,m3')

        if self.units == 'Metric':

            lines.append('*** x  - x       Mm3      for each possible   exit' +
                         '    for each possible exit,m3')

        for r in self.rchreses:

            lines.append('%5d%15.3f%10d%5d%5d%5d%5d%10d%5d%5d%5d%5d' % 
                         r.get_hydr_init())

        lines = lines + ['  END HYDR-INIT', '']

        # add the sediment transport

        if sediment:

            lines = lines + ['  SANDFG', '*** RCHRES', '*** x -  x SNDFG']

            for r in self.rchreses: lines.append('%5d%10d' % r.get_sandfg())

            lines = lines + ['  END SANDFG', 
                             '',
                             '  SED-GENPARM',
                             '*** RCHRES    BEDWID    BEDWRN       POR',
                             '*** x -  x       (m)       (m)']

            for r in self.rchreses: 
                lines.append('%5d%15.2f%10.2f%10.2f' % r.get_genparm())

            lines = lines + ['  END SED-GENPARM',
                             '',
                             '  SAND-PM',
                             '*** RCHRES         D         W       ' +
                             'RHO     KSAND    EXPSND',
                             '*** x -  x       (mm)  (mm/sec)  (gm/cm3)']

            for r in self.rchreses: 
                lines.append('%5d%15.3f%10.2f%10.2f%10.2f%10.2f' % 
                             r.get_sand_pm())

            lines = lines + ['  END SAND-PM',
                             '',
                             '  SILT-CLAY-PM',
                             '*** RCHRES         D         W       RHO     ' +
                             'TAUCD     TAUCS         M',
                             '***             (mm)  (mm/sec)   (gm/cm3)  ' +
                             '(kg/m2)   (kg/m2)(kg/m2.dy)']

            for r in self.rchreses:
                lines.append('%5d%15.4f%10.4f%10.2f%10.2f%10.2f%10.2f' %
                             r.get_silt_pm())

            lines = lines + ['  END SILT-CLAY-PM',
                             '',
                             '  SILT-CLAY-PM',
                             '*** RCHRES         D         W       RHO     ' +
                             'TAUCD     TAUCS         M',
                             '***             (mm)  (mm/sec)   (gm/cm3)  ' +
                             '(kg/m2)   (kg/m2)(kg/m2.dy)']

            for r in self.rchreses:
                lines.append('%5d%15.4f%10.4f%10.2f%10.2f%10.2f%10.2f' %
                             r.get_clay_pm())
        
            lines = lines + ['  END SILT-CLAY-PM',
                             '',
                             '  SSED-INIT',
                             '*** RCHRES     Suspended sed concs (mg/l)',
                             '*** x -  x      Sand      Silt      Clay']

            for r in self.rchreses: 
                lines.append('%5d%15.2f%10.2f%10.2f' % r.get_ssed_init())

            lines = lines + ['  END SSED-INIT',
                             '',
                             '  BED-INIT',
                             '*** RCHRES    BEDDEP  Initial bed composition',
                             '*** x -  x       (m)      Sand      Silt' +
                             '      Clay']

            for r in self.rchreses: 
                lines.append('%5d%15.2f%10.3f%10.3f%10.3f' % r.get_bed_init())

            lines = lines + ['  END BED-INIT', '']

        # finish up

        lines = lines[:-1] + ['END RCHRES', '']

        return lines

    def ext_sources_block(self, reach = False, temp = False, snow = False, 
                          hydrology = False, sediment = False, verbose = False):
        """Adds the block of lines for the external data sources (timeseries)
        for an HSPF model."""

        # units

        if   self.units == 'English': units = 'ENGL'
        elif self.units == 'Metric':  units = 'METR'
                
        lines = ['EXT SOURCES',
                 '<-Volume-> <Member> SsysSgap<--Mult-->Tran ' +
                 '<-Target vols> <-Grp> <-Member-> ***',
                 '<Name>   x <Name> x tem strg<-factor->strg <Name>' +
                 '   x   x        <Name> x x ***']

        # operations

        otypes, nmins, nmaxs = [], [], []

        if len(self.perlnds) > 0: 
            otypes.append('PERLND')
            nmins.append(min([p.operation for p in self.perlnds]))
            nmaxs.append(max([p.operation for p in self.perlnds]))
        if len(self.implnds) > 0: 
            otypes.append('IMPLND')
            nmins.append(min([i.operation for i in self.implnds]))
            nmaxs.append(max([i.operation for i in self.implnds]))
        if len(self.rchreses) > 0 and reach: 
            otypes.append('RCHRES')
            nmins.append(min([r.operation for r in self.rchreses]))
            nmaxs.append(max([r.operation for r in self.rchreses]))

        # assign watershed-wide timeseries

        for tstype, identifier in self.watershed_timeseries.items():

            if tstype == 'precipitation':

                group  = 'EXTNL'
                dtype  = 'PREC'
                gtype  = 'PREC'
                factor = '1.00'

            elif tstype == 'evaporation':

                group  = 'EXTNL'
                dtype  = 'EVAP'
                factor = '{:5.3f}'.format(self.evap_multiplier)

            elif tstype == 'temperature':

                group  = 'EXTNL'
                dtype  = 'TOBS'
                gtype  = 'GATMP'
                factor = '1.00'

            elif tstype == 'dewpoint':

                group  = 'EXTNL'
                dtype  = 'DEWT'
                factor = '1.00'

            elif tstype == 'wind':

                group  = 'EXTNL'
                dtype  = 'WIND'
                factor = '1.00'

            elif tstype == 'solar':

                group  = 'EXTNL'
                dtype  = 'SOLR'
                factor = '1.00'

            else: dtype = None

            # find the dsn

            for dsn, comid, ts in self.dsns:

                if comid == identifier and ts == dtype: break

            # format and add the lines

            for otype, nmin, nmax in zip(otypes, nmins, nmaxs):

                if otype == 'RCHRES' and tstype == 'evaporation':
                    gtype = 'POTEV'
                elif tstype == 'evaporation':
                    gtype = 'PETINP'

                if otype == 'RCHRES' and tstype == 'dewpoint':
                    gtype = 'DEWTMP'
                elif tstype == 'dewpoint': 
                    gtype  = 'DTMPG'

                if otype == 'RCHRES' and tstype == 'wind':
                    gtype = 'WIND'
                elif tstype == 'wind': 
                    gtype  = 'WINMOV'

                if tstype == 'solar': 
                    gtype  = 'SOLRAD'

                if dtype is not None:
                    v1 = (dsn, dtype, units, factor)
                    v2 = (otype, nmin, nmax, group, gtype)
                    l = ('WDM1{0:>6} {1:<9}{2:}ZERO{3:>10}SAME '.format(*v1)
                         + '{0:.6}{1:>4}{2:>4} {3:<6} {4:<6}'.format(*v2))
                    lines.append(l)

        # subbasin timeseries

        for tstype, d in self.subbasin_timeseries.items():

            if tstype == 'precipitation':

                group  = 'EXTNL'
                dtype  = 'PREC'
                gtype  = 'PREC'
                factor = '1.00'

            elif tstype == 'evaporation':

                group  = 'EXTNL'
                dtype  = 'EVAP'
                factor = '{:5.3f}'.format(self.evap_multiplier)

            elif tstype == 'temperature':

                group  = 'EXTNL'
                dtype  = 'TOBS'
                gtype  = 'GATMP'
                factor = '1.00'

            elif tstype == 'dewpoint':

                group  = 'EXTNL'
                dtype  = 'DEWT'
                factor = '1.00'

            else: dtype = None

            # for each subbasin, assign timeseries to all operations

            for subbasin, identifier in d.items():

                # find the dsn

                if dtype is not None:

                    for dsn, comid, ts in self.dsns:

                        if comid == identifier and ts == dtype: break

                    # assign to all operations

                    for o in self.perlnds + self.implnds:

                        if (o.landtype in self.landtypes[subbasin] and 
                            o.comid == subbasin):

                            if   o.landtype == 'Reach':      otype = 'RCHRES'
                            elif o.landtype == 'Impervious': otype = 'IMPLND'
                            else:                            otype = 'PERLND'

                            if o.landtype == 'Reach' and tstype == 'dewpoint':
                                gtype = 'DEWTMP'
                            elif tstype == 'dewpoint': 
                                gtype  = 'DTMPG'

                            if o.landtype == 'Reach' and tstype =='evaporation':
                                gtype = 'POTEV'
                            elif tstype == 'evaporation':
                                gtype = 'PETINP'

                            v1 = (dsn, dtype, units, factor)
                            v2 = (otype, o.operation, '     ', group, gtype)

                            l=('WDM1{0:>6} {1:<9}{2:}ZERO{3:>10}'.format(*v1)
                               +'SAME {0:.6}{1:>4}{2}{3:<6} {4:<6}'.format(*v2))

                            lines.append(l)

        # landuse timeseries

        for tstype, ldict in self.landuse_timeseries.items():

            for landtype, identifier in ldict.items():

                # append time series type as needed

                if tstype == 'evaporation':

                    group  = 'EXTNL'
                    dtype  = 'EVAP'
                    factor = '{:5.3f}'.format(self.evap_multiplier)

                # find the dsn

                for dsn, comid, ts in self.dsns:

                    if comid == identifier and ts == dtype: break

                # assign to all operations

                for o in self.perlnds + self.implnds:

                    if o.landtype == landtype:
                  
                        if   o.landtype == 'Reach':      otype = 'RCHRES'
                        elif o.landtype == 'Impervious': otype = 'IMPLND'
                        else:                            otype = 'PERLND'

                        if o.landtype == 'Reach' and tstype == 'evaporation':
                            gtype = 'POTEV'
                        elif tstype == 'evaporation':
                            gtype = 'PETINP'

                        v1 = (dsn, dtype, units, factor)
                        v2 = (otype, o.operation, '     ', group, gtype)

                        l = ('WDM1{0:>6} {1:<9}{2:}ZERO{3:>10}'.format(*v1)
                             + 'SAME {0:.6}{1:>4}{2}{3:<6} {4:<6}'.format(*v2))

                        lines.append(l)
     
        # operation timeseries

        for tstype, tdict in self.operation_timeseries.items(): 

            if tstype == 'inflow':

                group  = 'INFLOW'
                dtype  = 'FLOW'
                factor = '1.00'
                gtype  = 'IVOL'

            if tstype == 'wateryield':

                group  = 'SNOW'
                dtype  = 'WYIE'
                factor = '1.00'
                gtype  = 'WYIELD'

            if tstype == 'rain':

                group  = 'SNOW'
                dtype  = 'RAIN'
                factor = '1.00'
                gtype  = 'RAINF'

            if tstype == 'snowcover':

                group  = 'SNOW'
                dtype  = 'SCOV'
                factor = '1.00'
                gtype  = 'SNOCOV'

            if tstype == 'ice':

                group  = 'SNOW'
                dtype  = 'ICE'
                factor = '1.00'
                gtype  = 'PACKI'

            for subbasin, sdict in tdict.items():

                for landtype, identifier in sdict.items():

                    if   landtype == 'Impervious': otype = 'IMPLND'
                    elif landtype == 'Reach':      otype = 'RCHRES'
                    else:                          otype = 'PERLND'

                    n = self.landtypes[subbasin][landtype].operation

                    # find the dsn

                    for dsn, comid, ts in self.dsns:

                        if comid == identifier and ts == dtype: break

                    v1 = (dsn, dtype, units, factor)
                    v2 = (otype, n, '     ', group, gtype)

                    l = ('WDM1{0:>6} {1:<9}{2:.4}ZERO{3:>10}'.format(*v1)
                         + 'SAME {0:.6}{1:>4}{2}{3:<6} {4:<6}'.format(*v2))

                    lines.append(l)

        lines = lines + ['END EXT SOURCES', '']

        return lines

    def schematic_block(self):
        """Adds the SCHEMATIC block to a UCI file."""

        # add the title block

        lines = ['SCHEMATIC',
                 '<-Volume->                  <--Area-->     ' +
                 '<-Volume->  <ML#> ***       <sb>',
                 '<Name>   x                  <-factor->     <Name>   x' +
                 '        ***        x x']

        # add the linkages between the reaches

        comids = [r.comid for r in self.rchreses]

        for comid in self.updown:

            # check to see if it is an outlet

            if self.updown[comid] != 0:

                # find the upstream and downstream reach operation numbers

                up   = self.rchreses[comids.index(comid)]
                down = self.rchreses[comids.index(self.updown[comid])]

                # add the line (note reach-reach connections are now assumed to
                # be MASS-LINK 1)

                lines.append('RCHRES%4d%28d     RCHRES%4d%7d' % 
                             (up.operation, 1, down.operation, 1))

        # add the linkages from the perlnds and implnds to the reaches

        for r in self.rchreses:

        # find all the perlnds that feed the reach

            for p in self.perlnds:

                if p.comid == r.comid:

                    # add the line (note perlnd-reach connections are now 
                    # assumed to be MASS-LINK 2)

                    lines.append('PERLND%4d%28.3f     RCHRES%4d%7d' % 
                                 (p.operation, p.area, r.operation, 2))

            # find all the implnds that feed the reach

            for i in self.implnds:

                if i.comid == r.comid:

                    # add the line (note implnd-reach connections are now 
                    # assumed to be MASS-LINK 3)
                
                    lines.append('IMPLND%4d%28.3f     RCHRES%4d%7d' %
                                 (i.operation, i.area, r.operation, 3))

        lines = lines + ['END SCHEMATIC', '']

        return lines

    def masslink_block(self, hydrology = True, sediment = False, 
                       per_sed_fs = [0.01, 0.75, 0.24],
                       imp_sed_fs = [0.10, 0.46, 0.44]):
        """Makes the MASS-LINK block for a UCI file. The assumption is that 
        reach-reach connections are ML 1, perlnd-reach connections are ML 2, 
        implnd-reach connections are ML 3. Also assumes units of areas are
        km2 for metric and acres for English."""

        lines = ['MASS-LINK',
                 '  MASS-LINK        1',
                 '<-Volume-> <-Grp> <-Member-><--Mult-->     ' +
                 '<-Target vols> <-Grp> <-Member->  ***',
                 '<Name>            <Name> x x<-factor->     <Name>' +
                 '                <Name> x x  ***']

        lines.append('RCHRES     ROFLOW                          ' +
                     'RCHRES         INFLOW         ')

        lines = lines + ['  END MASS-LINK    1', 
                         '',
                         '  MASS-LINK        2',
                         '<-Volume-> <-Grp> <-Member-><--Mult-->     ' +
                         '<-Target vols> <-Grp> <-Member->  ***',
                         '<Name>            <Name> x x<-factor->     <Name>' +
                         '                <Name> x x  ***']

        # conversion factors

        if self.units == 'English':  
            fact  = 0.08333
            sfact = 1
        elif self.units == 'Metric': 
            fact  = 0.001
            sfact = 100
            
        if hydrology: 
            lines.append('PERLND     PWATER PERO {:>15.5f}     '.format(fact) +
                         'RCHRES         INFLOW IVOL    ')

        if sediment:  

            if self.units == 'English':  
                fs = per_sed_fs
            elif self.units == 'Metric': 
                fs = [f * sfact for f in per_sed_fs]

            lines.append('PERLND     SEDMNT SOSED  1  %10.3f' % fs[0] +
                         '     RCHRES         INFLOW ISED   1 ')
            lines.append('PERLND     SEDMNT SOSED  1  %10.3f' % fs[1] +
                         '     RCHRES         INFLOW ISED   2 ')
            lines.append('PERLND     SEDMNT SOSED  1  %10.3f' % fs[2] +
                         '     RCHRES         INFLOW ISED   3 ')

        lines = lines + ['  END MASS-LINK    2',
                         '',
                         '  MASS-LINK        3',
                         '<-Volume-> <-Grp> <-Member-><--Mult-->     ' +
                         '<-Target vols> <-Grp> <-Member->  ***',
                         '<Name>            <Name> x x<-factor->     <Name>' +
                         '                <Name> x x  ***']

        if hydrology: 
            lines.append('IMPLND     IWATER SURO {:>15.5f}     '.format(fact) +
                         'RCHRES         INFLOW IVOL    ')

        if sediment:  

            if self.units == 'English':  
                fs = imp_sed_fs
            elif self.units == 'Metric': 
                fs = [f * sfact for f in imp_sed_fs]

            lines.append('IMPLND     SOLIDS SOSLD  1  %10.3f' % fs[0] +
                         '     RCHRES         INFLOW ISED   1 ')
            lines.append('IMPLND     SOLIDS SOSLD  1  %10.3f' % fs[1] +
                         '     RCHRES         INFLOW ISED   2 ')
            lines.append('IMPLND     SOLIDS SOSLD  1  %10.3f' % fs[2] +
                         '     RCHRES         INFLOW ISED   3 ')

        lines = lines + ['  END MASS-LINK    3',
                         'END MASS-LINK',
                         '']

        return lines

    def ftables_block(self):
        """Adds the FTABLE blocks to the UCI file."""

        lines = ['FTABLES']

        for r in self.rchreses:

            ftable = [row for row in r.get_ftable() if row[-1] < 10**7]

            lines = lines + ['  FTABLE    %3d' % r.operation,
                             ' rows cols                               ***',
                             '%5d%5d' % (len(ftable), len(ftable[0])),
                             '     depth      area    volume  outflow1 ***']

            for row in ftable:
                lines.append('{:10.4g}{:10.4g}{:10.5g} {:9.4g}'.format(*row))

            lines.append('  END FTABLE%3d' % r.operation)
            lines.append('')

        lines = lines[:-1] + ['END FTABLES', '']

        return lines

class Perlnd:
    """A class for a pervious land segment for an HSPF model."""

    def __init__(self, operation, comid, landtype, area, length, slope, melev,
                 belv, lat, 
                 ATMP = False, SNOW = False, PWAT = False,  SED  = False, 
                 PST  = False, PWG  = False, PQAL = False, MSTL = False, 
                 PEST = False, NITR = False, PHOS = False, TRAC = False):
        """Sets up the modules and basic info for the PERLND."""

        # identification information

        self.operation  = operation  # the HSPF operation number (1-999)
        self.comid      = comid      # the NHDPlus comid of the outlet
        self.landtype   = landtype   # the landuse category

        # physically-based parameters (units consistent with HSPF formulation)

        self.area       = area     # the area of the land segment
        self.MELEV      = melev    # the mean elevation of the segment
        self.BELV       = belv     # the bottom elevation of the segment
        self.lat        = lat      # the mean latitude of the segment
        self.LSUR       = length   # overland flow plane length (0.3 m or more)
        self.SLSUR      = slope    # overland flow slope

        # the rest are flags for HSPF modules

        self.ATMP       = ATMP
        self.SNOW       = SNOW
        self.PWAT       = PWAT
        self.SED        = SED
        self.PST        = PST
        self.PWG        = PWG
        self.PQAL       = PQAL
        self.MSTL       = MSTL
        self.PEST       = PEST
        self.NITR       = NITR
        self.PHOS       = PHOS
        self.TRAC       = TRAC

    def set_land_parms(self, monLZETP = False):
        """Set parameters related to land use categories."""

        crops = ['Corn', 'Soybeans', 'Other grain', 'Hay/alfalfa', 'Other',
                 'Agriculture']

        # forest cover percent

        if self.landtype == 'Forest': self.FOREST = 0.75 
        else:                         self.FOREST = 0. 

        # lower zone evapotranspiration parameter. the following values are
        # defaults, and the LZETP_multiplier in the HSPFModel class is used to 
        # control these for land use categories in a given watershed.

        if   self.landtype == 'Water/wetland': self.LZETP = 0.8
        elif self.landtype == 'Forest':        self.LZETP = 0.6

        elif self.landtype in crops and monLZETP:
            self.LZETP = 0
            self.VLE   = 1
            self.set_monthly('LZETPARM',
                             values = [0.1, 0.1,  0.1,  0.2,  0.3,  0.4,
                                       0.5, 0.6,  0.6,  0.3,  0.2,  0.1])

        elif self.landtype == 'Pasture/grass': self.LZETP = 0.3
        elif self.landtype == 'Developed':     self.LZETP = 0.2
        elif self.landtype == 'Fallow land':   self.LZETP = 0.1
        else:                                  self.LZETP = 0.5

        # canopy storage

        if self.landtype == 'Corn':
            if self.units == 'Metric':
                values = [0.1, 0.1, 0.3, 0.7, 1.3, 2, 
                          3.6, 5., 5., 1.3, 0.3, 0.1]
            elif self.units == 'English':
                values = [0.02, 0.02, 0.02, 0.05, 0.08, 0.1,
                          0.14, 0.19, 0.20, 0.1, 0.03, 0.02]
                
            self.CEPSC = 0
            self.VCSFG = 1
            self.set_monthly('INTERCEP', values = values)

        if self.landtype == 'Soybeans':
            if self.units == 'Metric':
                values = [0.1, 0.1, 0.3, 0.6, 1., 1.5, 
                          2., 2., 2., 1., 0.3, 0.1]
            elif self.units == 'English':
                values = [0.02, 0.02, 0.02, 0.03, 0.06, 0.1,
                          0.1, 0.1, 0.1, 0.06, 0.03, 0.02]               
            self.CEPSC = 0
            self.VCSFG = 1
            self.set_monthly('INTERCEP', values = values)

        # nominal soil moisture capacity (related to rooting depth)

        if self.units == 'Metric':

            lzsns = {'Water/wetland': 200,
                     'Forest':        200,
                     'Agriculture':   150,
                     'Pasture/grass': 100,
                     'Developed':      50,
                     'Fallow land':    50
                     }
            lzsndefault = 100

        elif self.units == 'English':

            lzsns = {'Water/wetland': 8,
                     'Forest':        8,
                     'Agriculture':   6,
                     'Pasture/grass': 4,
                     'Developed':     2,
                     'Fallow land':   2
                     }
            lzsndefault = 4

        if   self.landtype in crops:     self.LZSN = lzsns['Agriculture']
        elif self.landtype not in lzsns: self.LZSN = lzsndefault
        else:                            self.LZSN = lzsns[self.landtype]

        # high water table (wetlands)

        self.HWT = 0
        if self.landtype == 'Water/wetland': 
            #self.HWT = 1 # wetland flag (had issues trying this so needs work)
            self.AGWETP = 0.7 # PET fraction satisfied by groundwater (0 to 1)
            self.RTOP   = 2
        else:                           
            #self.HWT = 0
            self.AGWETP = 0
            self.RTOP = 1

    def set_pwat_parms(self, units, VCS = 1, VUZ = 0, VNN = 1, VIFW = 0, 
                       VIRC = 0, VLE = 0):
        """Shortcut function to set each PWAT block."""

        self.units = units # English or Metric

        self.set_pwat_parm1(VCS = VCS, VUZ = VUZ, VNN = VNN, VIFW = VIFW,
                            VIRC = VIRC, VLE = VLE)
        self.set_pwat_parm2()
        self.set_pwat_parm3()
        self.set_pwat_parm4()
        self.set_pwat_parm5()
        self.set_pwat_parm6()
        self.set_pwat_parm7()

        # sort of hack way of setting English values for parameters

        if self.units == 'English':

            self.PETMAX = 40
            self.PETMIN = 35
            self.INFILT = 0.04
            self.UZSN   = 1.

        # set monthly defaults as needed

        if self.VCS  == 1: self.set_monthly('INTERCEP')
        if self.VUZ  == 1: self.set_monthly('UZSN')
        if self.VNN  == 1: self.set_monthly('MANNING')
        if self.VIFW == 1: self.set_monthly('INTERFLW')
        if self.VIRC == 1: self.set_monthly('IRC')
        if self.VLE  == 1: self.set_monthly('LZETPARM')

        # override default values for landuse-specific files

        self.set_land_parms()

        # initial state variables

        self.set_pwat_state()

    def set_pwat_parm1(self, CSNO = 0, RTOP = 1, UZFG = 1, VCS = 0, VUZ = 0, 
                             VNN  = 0, VIFW = 0, VIRC = 0, VLE = 0, IFFC = 1, 
                             HWT  = 0, IRRG = 0):
        """sets up flags (PARM1) for the PWATER module."""

        # algorithm flags

        self.CSNO = CSNO    # snow flag (0 or 1)
        self.HWT  = HWT     # high water table flag (0 or 1)
        if self.HWT == 0:   self.RTOP = RTOP  
                            # overland flow routing (0: functional description
                            #                        1: HSPX, ARM and NPS method
                            #                        2: high water table
                            #                        3: high water table)
        else:               self.RTOP = 2
        self.UZFG = UZFG    # upper zone inflow method (0 or 1 unless wetland)
        self.IFFC = IFFC    # frozen ground effect on infiltration (0, 1, 2) 
        #self.HWT  = HWT    # high water table/low gradient (wetlands, 0 or 1)
        self.IRRG = IRRG    # irrigation demand (0, 1, 2, 3)

        # parameters that can vary by month flags (0 or 1)

        self.VCS  = VCS     # interception storage capacity 
        self.VUZ  = VUZ     # upper zone nominal storage parameter
        self.VNN  = VNN     # Manning's n for the overland flow plane
        self.VIFW = VIFW    # interflow inflow parameter
        self.VIRC = VIRC    # interflow recession constant
        self.VLE  = VLE     # lower zone evapotranspiration (E-T) parameter

        # default monthly values for those parameters

        if self.units == 'Metric':
            self.CEPSCdefaults = [0.75, 0.75, 0.75, 2.5, 2.5, 2.5, 3.75, 3.75, 
                                  2.5, 1.25, 0.75, 0.75]
            self.UZSNdefaults  = [63., 61., 57., 50., 44., 39., 38., 40., 45., 
                                  51., 58., 62.]
        elif self.units == 'English':
            self.CEPSCdefaults = [0.03, 0.03, 0.03, 0.1, 0.1, 0.1, 0.15, 0.15, 
                                  0.1, 0.05, 0.03, 0.03]
            self.UZSNdefaults  = [2.5, 2.3, 2.1, 2., 1.8, 1.7, 1.8, 1.8, 1.9, 
                                  2., 2.2, 2.3]
        self.NSURdefaults  = [0.25, 0.24, 0.22, 0.2, 0.17, 0.16, 0.15, 
                              0.16, 0.18, 0.2, 0.23, 0.24]
        self.INTFWdefaults = [10.0 for i in range(12)]
        self.IRCdefaults   = [0.6  for i in range(12)]
        self.LZETPdefaults = [0.5  for i in range(12)]

    def get_pwat_parm1(self):
        """Returns the PWAT-PARM1 flags as a tuple."""

        return (self.operation,     self.CSNO, self.RTOP, self.UZFG, self.VCS, 
                self.VUZ, self.VNN, self.VIFW, self.VIRC, self.VLE, self.IFFC, 
                self.HWT, self.IRRG)
        
    def set_pwat_parm2(self, INFILT = 1., KVARY = 0., AGWRC = 0.95):
        """Sets the values for some parameters (PWAT2) in the PWATER module.
        Note that LSUR and SLSUR come from physical data so they are not
        set here."""

        #self.FOREST = FOREST # fraction covered by forest (0. to 1.), SNOW only
        #self.LZSN   = LZSN    # lower zone nominal storage (.25 to 2500. mm)
        self.INFILT = INFILT  # infiltration capacity (0.0025 to 2500. mm/hr)
        #self.LSUR   = LSUR   # overland flow plane length (0.3 m or more)
        #self.SLSUR  = SLSUR  # overland flow slope (0.000001 to 10.)
        self.KVARY  = KVARY   # groundwater recession flow (0. mm-1 or more)
        self.AGWRC  = AGWRC   # basic groundwater recession rate, only applies
                              # if KVARY = 0,= today/yest (0.001 to 0.999 day-1)

    def get_pwat_parm2(self):
        """Returns the PWAT-PARM2 parameters as a tuple."""

        return (self.operation, self.FOREST, self.LZSN, self.INFILT, self.LSUR,
                self.SLSUR, self.KVARY, self.AGWRC)

    def set_pwat_parm3(self, PETMAX = 1., PETMIN = 0., INFEXP = 2., 
                       INFILD = 2., DEEPFR = 0., BASETP = 0.):
        """Sets the values for some parameters (PWAT3) in the PWATER module."""

        self.PETMAX = PETMAX # air temp where input ET is reduced
        self.PETMIN = PETMIN # air temp below which ET is zero
        self.INFEXP = INFEXP # infiltration equation exponent (0 to 10)
        self.INFILD = INFILD # ratio of max and mean infilt capacities  (1 to 2)
        self.DEEPFR = DEEPFR # inflow to inactive groundwater fraction  (0 to 1)
        self.BASETP = BASETP # fraction of PET satisfied by baseflow    (0 to 1)
        #self.AGWETP = AGWETP # fraction of PET satisfied by groundwater(0 to 1)
        
    def get_pwat_parm3(self):
        """Returns the PWAT-PARM3 parameters as a tuple."""

        return (self.operation, self.PETMAX, self.PETMIN, self.INFEXP, 
                self.INFILD, self.DEEPFR, self.BASETP, self.AGWETP)

    def set_pwat_parm4(self, CEPSC = 0., UZSN = 20., NSUR = 0.1, INTFW = 10., 
                       IRC = 0.6):
        """Sets the values for parameters that can vary by month but don't."""

        self.CEPSC = CEPSC # interception storage capacity
        self.UZSN  = UZSN  # upper zone nominal storage
        self.NSUR  = NSUR  # Manning's n for the overland flow plane
        self.INTFW = INTFW # interflow inflow parameter
        self.IRC   = IRC   # interflow recession parameter
        #self.LZETP = LZETP # lower zone ET parameter

    def get_pwat_parm4(self):
        """Returns the PWAT-PARM4 parameters as a tuple."""

        return (self.operation, self.CEPSC, self.UZSN, self.NSUR, self.INTFW,
                self.IRC, self.LZETP)

    def set_pwat_parm5(self, FZG = 0.0394, FZGL = 0.1):
        """Set the values for the parameters relating the effects of ice to
        infiltration rate."""

        self.FZG  = FZG
        self.FZGL = FZGL

    def get_pwat_parm5(self):
        """Return the PWAT-PARM5 parameters as a tuple."""

        return (self.operation, self.FZG, self.FZGL)

    def set_pwat_parm6(self, GWDATM = None, PCW = 0.4, PGW = 0.4, UPGW = 0.4):
        """Sets the values of the high water table parameters."""

        if GWDATM is None: self.GWDATM = self.BELV - 5
        else:              self.GWDATM = GWDATM

        self.PCW  = PCW   # cohesion water porosity
        self.PGW  = PGW   # gravitational water porosity
        self.UPGW = UPGW  # upper gravitational water porosity

    def get_pwat_parm6(self):
        """Returns the PWAT-PARM6 parameters as a tuple."""
        
        return (self.operation, self.MELEV, self.BELV, self.GWDATM, self.PCW,
                self.PGW, self.UPGW)

    def set_pwat_parm7(self, STABNO = 999, SRRC = 0.1, SREXP = 2., 
                       IFWSC = 20., DELTA = 0.025, UELFAC = 4., LELFAC = 2.5):
        """Sets the values for the high water table parameters."""

        self.STABNO = STABNO  # ftable number
        self.SRRC   = SRRC    # surface runoff recession coefficient
        self.SREXP  = SREXP   # surface runoff exponent
        self.IFWSC  = IFWSC   # maximum interflow storage capacity
        self.DELTA  = DELTA   # groundwater tolernace level
        self.UELFAC = UELFAC  # multiplier for upper zone storage capacity
        self.LELFAC = LELFAC  # multiplier for lower zone storage capacity

    def get_pwat_parm7(self):
        """Returns the values for PWAT-PARM7 as a tuple."""

        return (self.operation, self.STABNO, self.SRRC, self.SREXP, self.IFWSC,
                self.DELTA, self.UELFAC, self.LELFAC)
                       
    def set_pwat_state(self, CEPS = 0., SURS = 0., UZS = None, IFWS = 0., 
                       LZS = None, AGWS = 0., GWVS = 0.):
        """Sets the initial values for the state variables for PWATER."""

        self.CEPS = CEPS
        self.SURS = SURS
        self.IFWS = IFWS
        self.AGWS = AGWS
        self.GWVS = GWVS

        # default soil moisture values should be close to storage capacity

        if UZS is None: self.UZS = self.UZSN
        else:           self.UZS = UZS

        if LZS is None: self.LZS = self.LZSN
        else:           self.LZS = LZS

    def get_pwat_state(self):
        """Returns the initial values for the state variables for PWATER."""

        return (self.operation, self.CEPS, self.SURS, self.UZS, self.IFWS, 
                self.LZS, self.AGWS, self.GWVS)

    def set_monthly(self, name, values = None):
        """Returns a list of the monthly values of the parameter "name." """

        # establish monthly variable value lists

        if values is not None:

            if name == 'INTERCEP': self.monCEPSC = values
            if name == 'UZSN':     self.monUZSN  = values
            if name == 'MANNING':  self.monNSUR  = values
            if name == 'INTERFLW': self.monINTFW = values
            if name == 'IRC':      self.monIRC   = values
            if name == 'LZETPARM': self.monLZETP = values

        else:

            if name == 'INTERCEP': self.monCEPSC = self.CEPSCdefaults
            if name == 'UZSN':     self.monUZSN  = self.UZSNdefaults
            if name == 'MANNING':  self.monNSUR  = self.NSURdefaults
            if name == 'INTERFLW': self.monINTFW = self.INTFWdefaults
            if name == 'IRC':      self.monIRC   = self.IRCdefaults
            if name == 'LZETPARM': self.monLZETP = self.LZETPdefaults

    def get_monthly(self, name):
        """Returns a list of the monthly values of the parameter "name." """

        if name == 'INTERCEP': return self.monCEPSC
        if name == 'UZSN':     return self.monUZSN
        if name == 'MANNING':  return self.monNSUR
        if name == 'INTERFLW': return self.monINTFW
        if name == 'IRC':      return self.monIRC
        if name == 'LZETPARM': return self.monLZETP

    def set_atemp_dat(self, ELDAT = 0., AIRTMP = 0.):
        """Sets the data for adjusting gage temperature to land segment temp."""

        self.ELDAT  = ELDAT  # elevation difference between gage and segment (m)
        self.AIRTMP = AIRTMP # initial temperature (C)

    def get_atemp_dat(self):
        """Returns the ATEMP-DAT values."""

        return (self.operation, self.ELDAT, self.AIRTMP)

    def set_ice_flag(self, ICEFG = 1):
        """Sets the flag for ice simulation."""
        
        self.ICEFG = ICEFG # ice formation flag

    def get_ice_flag(self):
        """Returns the values of ICE-FLAG as a tuple."""

        return (self.operation, self.ICEFG)

    def set_snow_flags(self, SNOPFG = 0, VKMFG = 0):
        """Sets the flags for the snow module."""

        self.SNOPFG = SNOPFG # snow melt algorithm (0: energy, 1: temp index)
        self.VKMFG  = VKMFG  # monthly variable degree day flag 

    def get_snow_flags(self):
        """Returns the SNOW-FLAGS as a tuple."""

        return (self.operation, self.SNOPFG, self.VKMFG)

    def set_snow_parm1(self, SHADE = 0.15, SNOWCF = 1., COVIND = 10., 
                       KMELT = 0., TBASE = 0.):
        """Sets the snow melt parameter values. Note first two pre-defined."""

        #self.LAT    = LAT   # latitude
        #self.MELEV  = MELEV # mean elevation (m)
        self.SHADE  = SHADE  # land surface fraction shaded
        self.SNOWCF = SNOWCF # gage catch efficiency factor
        self.COVIND = COVIND # snowpack depth corresponding to full area cov.
        self.KMELT  = KMELT  # degree-day factor for SNOPFG = 1 (mm/d/C)
        self.TBASE  = TBASE  # reference temperature index (C)

    def get_snow_parm1(self):
        """Returns the SNOW-PARM1 values as a tuple."""

        return (self.operation, self.lat, self.MELEV, self.SHADE, self.SNOWCF,
                self.COVIND, self.KMELT, self.TBASE)

    def set_snow_parm2(self, RDCSN = 0.12, TSNOW = 2., SNOEVP = 0.1, 
                       CCFACT = 1., MWATER = 0.03, MGMELT = 0.25):
        """Sets snowpack parameter values."""

        self.RDCSN  = RDCSN  # snow density relative to water
        self.TSNOW  = TSNOW  # air temperature where snow occurs
        self.SNOEVP = SNOEVP # snow evaporation field adjustment
        self.CCFACT = CCFACT # condensation/convection field adjustment
        self.MWATER = MWATER # maximum water content of the snow pack
        self.MGMELT = MGMELT # maximum snowmelt rate (mm/day)

    def get_snow_parm2(self):
        """Returns the SNOW-PARM2 values as a tuple."""

        return (self.operation, self.RDCSN, self.TSNOW, self.SNOEVP, 
                self.CCFACT, self.MWATER, self.MGMELT)

    def set_snow_init1(self, packsnow = 0., packice = 0., packwatr = 0., 
                       RDENPF = 0.2, DULL = 400., PAKTMP = 0.):
        """Sets the initial snow pack conditions. Note all are in water-
        equivalent units."""

        self.packsnow = packsnow  # snow in pack (mm water)
        self.packice  = packice   # ice in snow pack (mm water)
        self.packwatr = packwatr  # water in snow pack (mm water)
        self.RDENPF   = RDENPF    # relative density of snow and ice to water
        self.DULL     = DULL      # dullness of pack (for albedo estimate)
        self.PAKTMP   = PAKTMP    # mean temperature of snow pack (C)

    def get_snow_init1(self):
        """Returns the values of SNOW-INIT1 as a tuple."""

        return (self.operation, self.packsnow, self.packice, self.packwatr,
                self.RDENPF, self.DULL, self.PAKTMP)

    def set_snow_init2(self, COVINX = 10., XLNMLT = 2.5, SKYCLR = 0.):
        """Sets the initial values of other snow parameters."""

        self.COVINX = COVINX # snow pack depth needed to cover segment (mm)
        self.XLNMLT = XLNMLT # increment to ice storage in the pack
        self.SKYCLR = SKYCLR # clear sky fraction

    def get_snow_init2(self):
        """Returns the values of SNOW-INIT2 as a tuple."""

        return (self.operation, self.COVINX, self.XLNMLT, self.SKYCLR)

    def set_sed_parm1(self, CRV = 0, VSIV = 0, SDOP = 0):
        """Sets the sediment transport flags for monthly variables."""

        self.CRV  = CRV  # erosion-related cover flag
        self.VSIV = VSIV # net vertical sediment input flag
        self.SDOP = SDOP # land surface removal algorithm flag

    def get_sed_parm1(self):
        """Returns the SED-PARM1 values as a tuple."""

        return (self.operation, self.CRV, self.VSIV, self.SDOP)

    def set_sed_parm2(self, SMPF = 1., KRER = 0.35, JRER = 2.0, AFFIX = None,
                      COVER = 0., NVSI = 1.):
        """Sets some of the sediment transport parameters."""

        self.SMPF  = SMPF  # supporting management practice factor (-)
        self.KRER  = KRER  # soil detachment coefficient (kg mm^-JRER hr^JRER-1)
        self.JRER  = JRER  # soil detachment exponent (-)
        #self.AFFIX = AFFIX# daily detached sediment fractional decrease (-)
        self.COVER = COVER # land surface shielded fraction (-)
        self.NVSI  = NVSI  # sediment deposition (or erosion) rate (kg/ha/day)

        # land use specific parameters

        crops = ['Corn', 'Soybeans', 'Other grain', 'Hay/alfalfa', 'Other',
                 'Agriculture']

        if AFFIX is None:
            if   self.landtype == 'Water/wetland': self.AFFIX = 0.002
            elif self.landtype == 'Forest':        self.AFFIX = 0.002
            elif self.landtype in  crops:          self.AFFIX = 0.01
            elif self.landtype == 'Pasture/grass': self.AFFIX = 0.005
            elif self.landtype == 'Developed':     self.AFFIX = 0.01
            elif self.landtype == 'Fallow land':   self.AFFIX = 0.01
            else:                                 self.AFFIX = 0
        else:               
            self.AFFIX = AFFIX
                     
    def get_sed_parm2(self):
        """Returns the SED-PARM2 values as a tuple."""

        return (self.operation, self.SMPF, self.KRER, self.JRER, self.AFFIX,
                self.COVER, self.NVSI)

    def set_sed_parm3(self, KSER = None, JSER = 2.0, KGER = 0., JGER = 1.):
        """Sets some of the sediment transport parameters."""

        self.KSER = KSER  # detached sediment washoff coeff (tonne/ha hr^JSER-1)
        self.JSER = JSER  # detached sediment washoff exponent (-)
        self.KGER = KGER  # matrix soil scour coefficient (needs work)
        self.JGER = JGER  # matrix soil scour exponent (-)

        # land use specific parameters

        crops = ['Corn', 'Soybeans', 'Other grain', 'Hay/alfalfa', 'Other',
                 'Agriculture']

        if KSER is None:
            if   self.landtype == 'Water/wetland': self.KSER = 0.2
            elif self.landtype == 'Forest':        self.KSER = 0.2
            elif self.landtype in  crops:          self.KSER = 1.0
            elif self.landtype == 'Pasture/grass': self.KSER = 0.2
            elif self.landtype == 'Developed':     self.KSER = 0.1
            elif self.landtype == 'Fallow land':   self.KSER = 0.2
            else:                                 self.KSER = 0.2
        else:               
            self.KSER = KSER

    def get_sed_parm3(self):
        """Returns the SED-PARM3 values as a tuple."""

        return (self.operation, self.KSER, self.JSER, self.KGER, self.JGER)

    def set_sed_stor(self, DETS = 0.2):
        """Sets the initial value of the detached sediment."""

        self.DETS = DETS

    def get_sed_stor(self):
        """Returns the value of the sediment storage."""

        return (self.operation, self.DETS)

class Implnd:
    """A class for an impervious land segment for an HSPF model."""

    def __init__(self, operation, comid, area, length, slope, elev, lat,
                 ATMP = False, SNOW = False, IWAT = False, SLD = False, 
                 IWG = False,  IQAL = False):

        # identification information

        self.operation  = operation    # the HSPF operation number (1-999)
        self.comid      = comid        # the NHDPlus comid of the outlet
        self.landtype   = 'Impervious' # land type (always the same)

        # physically-based parameters

        self.area       = area         # the area of the land segment
        self.LSUR       = length       # the overland flow plane length
        self.SLSUR      = slope        # the overland flow plane slope
        self.elev       = elev         # the mean elevation of the segment (m)
        self.lat        = lat          # the mean latitude of the segment (m)

        # the rest are flags for HSPF modules

        self.ATMP       = ATMP
        self.SNOW       = SNOW
        self.IWAT       = IWAT
        self.SLD        = SLD
        self.IWG        = IWG
        self.IQAL       = IQAL

    def set_iwat_parms(self, units, VRS = 0, VNN = 0):
        """Shortcut function to set each IWAT block."""

        self.units = units # English or Metric

        self.set_iwat_parm1()
        self.set_iwat_parm2()
        self.set_iwat_parm3()
        self.set_iwat_state1()

        if self.units == 'English':
            self.PETMAX = 40
            self.PETMIN = 35
            self.RETS   = 0.01
            self.SURS   = 0.01

    def set_iwat_parm1(self, CSNO = 0, RTOP = 1, VRS = 0, VNN = 0, RTLI = 0):
        """Sets the values for the parameter flags."""

        self.CSNO = CSNO
        self.RTOP = RTOP
        self.VRS  = VRS
        self.VNN  = VNN
        self.RTLI = RTLI
        
    def get_iwat_parm1(self):
        """Returns the values for the IWAT-PARM1 flags."""
        
        return (self.operation, self.CSNO, self.RTOP, self.VRS, self.VNN, 
                self.RTLI)

    def set_iwat_parm2(self, NSUR = 0.1, RETSC = 0):
        """Sets the values for some parameters (IWAT2) in the IWATER module.
        Note that LSUR and SLSUR come from physical data so they are not
        set here."""

        #self.LSUR   = LSUR   # overland flow plane length (0.3 m or more)
        #self.SLSUR  = SLSUR  # overland flow slope (0.000001 to 10.)
        self.NSUR   = NSUR   # overland flow manning's n
        self.RETSC  = RETSC  # interception storage capacity (mm)

    def get_iwat_parm2(self):
        """Gets the values for IWAT-PARM2."""

        return (self.operation, self.LSUR, self.SLSUR, self.NSUR, self.RETSC)
        
    def set_iwat_parm3(self, PETMAX = 1., PETMIN = 0.):
        """Sets the evapotranspiration parameters for IWATER."""

        self.PETMAX = PETMAX  # air temp where input ET is reduced
        self.PETMIN = PETMIN  # air temp below which ET is zero

    def get_iwat_parm3(self):
        """Returns the IWAT-PARM3 values."""

        return (self.operation, self.PETMAX, self.PETMIN)

    def set_iwat_state1(self, RETS = 0.025, SURS = 0.025):
        """Sets the value of the state variables. """

        self.RETS = RETS
        self.SURS = SURS

    def get_iwat_state1(self):
        """Gets the value of the IWAT-STATE1 parameters."""

        return (self.operation, self. RETS, self.SURS)

    def set_atemp_dat(self, ELDAT = 0., AIRTMP = 0.):
        """Sets the data for adjusting gage temperature to land segment temp."""

        self.ELDAT  = ELDAT  # elevation difference between gage and segment (m)
        self.AIRTMP = AIRTMP # initial temperature (C)

    def get_atemp_dat(self):
        """Returns the ATEMP-DAT values."""

        return [self.operation, self.ELDAT, self.AIRTMP]

    def set_ice_flag(self, ICEFG = 1):
        """Sets the flag for ice simulation."""
        
        self.ICEFG = ICEFG # ice formation flag

    def get_ice_flag(self):
        """Returns the values of ICE-FLAG as a tuple."""

        return [self.operation, self.ICEFG]

    def set_snow_flags(self, SNOPFG = 0, VKMFG = 0):
        """Sets the flags for the snow module."""

        self.SNOPFG = SNOPFG # snow melt algorithm (0: energy, 1: temp index)
        self.VKMFG  = VKMFG  # monthly variable degree day flag 

    def get_snow_flags(self):
        """Returns the SNOW-FLAGS as a tuple."""

        return [self.operation, self.SNOPFG, self.VKMFG]

    def set_snow_parm1(self, SHADE = 0.15, SNOWCF = 1., COVIND = 10., 
                       KMELT = 0., TBASE = 0.):
        """Sets the snow melt parameter values. Note first two pre-defined."""

        #self.LAT    = LAT   # latitude
        #self.MELEV  = MELEV # mean elevation (m)
        self.SHADE  = SHADE  # land surface fraction shaded
        self.SNOWCF = SNOWCF # gage catch efficiency factor
        self.COVIND = COVIND # snowpack depth corresponding to full area cov.
        self.KMELT  = KMELT  # degree-day factor for SNOPFG = 1 (mm/d/C)
        self.TBASE  = TBASE  # reference temperature index (C)

    def get_snow_parm1(self):
        """Returns the SNOW-PARM1 values as a tuple."""

        return [self.operation, self.lat, self.elev, self.SHADE, self.SNOWCF,
                self.COVIND, self.KMELT, self.TBASE]

    def set_snow_parm2(self, RDCSN = 0.12, TSNOW = 1., SNOEVP = 0.1, 
                       CCFACT = 1., MWATER = 0.03, MGMELT = 0.25):
        """Sets snowpack parameter values."""

        self.RDCSN  = RDCSN  # snow density relative to water
        self.TSNOW  = TSNOW  # air temperature where snow occurs
        self.SNOEVP = SNOEVP # snow evaporation field adjustment
        self.CCFACT = CCFACT # condensation/convection field adjustment
        self.MWATER = MWATER # maximum water content of the snow pack
        self.MGMELT = MGMELT # maximum snowmelt rate (mm/day)

    def get_snow_parm2(self):
        """Returns the SNOW-PARM2 values as a tuple."""

        return [self.operation, self.RDCSN, self.TSNOW, self.SNOEVP, 
                self.CCFACT, self.MWATER, self.MGMELT]

    def set_snow_init1(self, packsnow = 0., packice = 0., packwatr = 0., 
                       RDENPF = 0.2, DULL = 400., PAKTMP = 0.):
        """Sets the initial snow pack conditions. Note all are in water-
        equivalent units."""

        self.packsnow = packsnow  # snow in pack (mm water)
        self.packice  = packice   # ice in snow pack (mm water)
        self.packwatr = packwatr  # water in snow pack (mm water)
        self.RDENPF   = RDENPF    # relative density of snow and ice to water
        self.DULL     = DULL      # dullness of pack (for albedo estimate)
        self.PAKTMP   = PAKTMP    # mean temperature of snow pack (C)

    def get_snow_init1(self):
        """Returns the values of SNOW-INIT1 as a tuple."""

        return [self.operation, self.packsnow, self.packice, self.packwatr,
                self.RDENPF, self.DULL, self.PAKTMP]

    def set_snow_init2(self, COVINX = 12., XLNMLT = 2.5, SKYCLR = 0.):
        """Sets the initial values of other snow parameters."""

        self.COVINX = COVINX # snow pack depth needed to cover segment (mm)
        self.XLNMLT = XLNMLT # increment to ice storage in the pack
        self.SKYCLR = SKYCLR # clear sky fraction

    def get_snow_init2(self):
        """Returns the values of SNOW-INIT2 as a tuple."""

        return [self.operation, self.COVINX, self.XLNMLT, self.SKYCLR]

    def set_sld_parm1(self, VASD = 0, VRSD = 0, SDOP = 0):
        """Sets the flags of the sediment transport parameters."""

        self.VASD = VASD # monthly accumulation rate of solids flag
        self.VRSD = VRSD # unit removal flag
        self.SDOP = SDOP # sediment removal algorithm flag
        
    def get_sld_parm1(self):
        """Returns the SLD-PARM1 flags."""

        return (self.operation, self.VASD, self.VRSD, self.SDOP)

    def set_sld_parm2(self, KEIM = 2., JEIM = 1.8, ACCSDP = 0.0001, REMSDP =0.):
        """Sets the value of the sediment transport parameters."""

        self.KEIM   = KEIM   # solids washoff coefficient (needs work)
        self.JEIM   = JEIM   # solids washoff exponenet (-)
        self.ACCSDP = ACCSDP # rate of deposition (tonnes/ha/day)
        self.REMSDP = REMSDP # fraction of solids storage removed daily (-)

    def get_sld_parm2(self):
        """Returns the SLD-PARM2 parameters as a tuple."""
        
        return (self.operation, self.KEIM, self.JEIM, self.ACCSDP, self.REMSDP)

    def set_sld_stor(self, SLDS = 0.):
        """Sets the initial values of the storage."""

        self.SLDS = SLDS # solids storage (tonnes)

    def get_sld_stor(self):
        """Returns the SLD-STOR values."""

        return (self.operation, self.SLDS)

class Rchres:
    """A class for a reach of a water body for an HSPF model."""

    def __init__(self, operation, comid, gnis, length, delth, flow, velocity, 
                 nexits = 1, lake = False, ftable = None, dam = None,
                 HYFG = False, ADFG = False, CNFG = False, HTFG = False, 
                 SDFG = False, GQFG = False, OXFG = False, NUFG = False, 
                 PKFG = False, PHFG = False):
        """Sets the basic reach properties and the activity flags for RCHRES."""

        self.operation = operation
        self.comid     = comid
        self.landtype  = 'Reach'  # land type (always the same)
        self.gnis      = gnis
        self.length    = length
        self.delth     = delth
        self.flow      = flow
        self.velocity  = velocity
        self.nexits    = nexits
        self.ftable    = ftable
        self.dam       = dam

        if dam is not None: self.lake = True
        else:               self.lake = False

        self.HYFG = HYFG
        self.ADFG = ADFG
        self.CNFG = CNFG
        self.HTFG = HTFG
        self.SDFG = SDFG
        self.GQFG = GQFG
        self.OXFG = OXFG
        self.NUFG = NUFG
        self.PKFG = PKFG
        self.PHFG = PHFG

    def set_hydr_parms(self, units):
        """Shortcut function to set each PWAT block."""

        self.units = units # English or Metric

        self.set_hydr_parm1()
        self.set_hydr_parm2()
        self.set_hydr_init()

        if self.ftable is None: self.set_ftable()

    def set_hydr_parm1(self, VCFG = 0, ODFVFG = 4, ODGTFG = 0, A1FG = 1,
                       A2FG = 1, A3FG = 1, FUNCT = 1):
        """Sets the hydraulic flags."""

        self.VCFG   = VCFG
        self.ODFVFG = ODFVFG
        self.ODGTFG = ODGTFG
        self.A1FG   = A1FG
        self.A2FG   = A2FG
        self.A3FG   = A3FG
        self.FUNCT  = FUNCT

        # hack way to set English defaults

        if self.units == 'English': self.DB50 = 0.01

    def get_hydr_parm1(self):
        """Returns the HYDR-PARM1."""

        ODFGs  = (tuple(self.ODFVFG for i in range(self.nexits)) + 
                  tuple(0 for i in range(5 - self.nexits)))
        ODGTs  = (tuple(self.ODGTFG for i in range(self.nexits)) +
                  tuple(0 for i in range(5 - self.nexits)))
        FUNCTs = tuple(self.FUNCT for i in range(5))
        
        return ((self.operation, self.VCFG, self.A1FG, self.A2FG, self.A3FG,)
                + ODFGs + ODGTs + FUNCTs)

    def set_hydr_parm2(self, FDSN = 0, STCOR = 0, KS = 0.5, DB50 = 0.25):
        """Sets some of the hydraulic parameters."""

        self.FDSN  = FDSN
        self.STCOR = STCOR
        self.KS    = KS
        self.DB50  = DB50

    def get_hydr_parm2(self):
        """Returns the HYDR-PARM2 values."""

        return (self.operation, self.FDSN, self.operation, self.length, 
                self.delth, self.STCOR, self. KS, self.DB50)

    def set_hydr_init(self, VOL = None, CAT = 0, CATI = 4, OUTDGT = 0):
        """Sets the intial values for the HYDR state variables."""

        if VOL is None:

            if self.units == 'Metric':
                conv1 = 10.764 # ft2 per m2
                conv2 = 1000   # km2 * mm to Mm3
            elif self.units == 'English':
                conv1 = 1
                conv2 = 43560 / 5280 # miles ft2 to acre-ft

            if self.lake:

                v = self.dam.norm_storage

                # convert

                if   self.units == 'Metric':  conv = 0.0012335
                elif self.units == 'English': conv = 1

                # set the lake volume 1 % above the minimum level to prevent 
                # numerical errors

                self.VOL = v * conv * 1.01

            else:

                area   = self.flow / self.velocity / conv1  # m2 or ft2
                volume = self.length * area / conv2         # Mm3 or acre-ft
            
                # winter flows are well below average so set to 1/5

                self.VOL = volume / 5

        else: self.VOL = VOL

        self.CAT    = CAT
        self.CATI   = CATI
        self.OUTDGT = OUTDGT

    def get_hydr_init(self):
        """Gets the values for HYDR-INIT."""

        return ((self.operation, self.VOL) + tuple(self.CATI for i in range(5))
                + tuple(self.OUTDGT for i in range(5)))
 
    def set_ftable(self):
        """Sets the FTABLE for the reach."""

        from pyhspf.core.ftable import make_ftable, lake_ftable

        s = self.delth / self.length / 1000

        # work around for very flat areas

        if s < 0.00001: s = 0.00001

        if not self.lake:
            self.ftable = make_ftable(self.flow, self.velocity, self.length, s)

        elif self.dam is not None:
            self.ftable = lake_ftable(self.flow, self.velocity, self.length, s,
                                      self.dam)

    def get_ftable(self):
        """Returns the FTABLE for the reach."""

        return self.ftable

    def set_sandfg(self, SANDFG = 3):
        """Sets the SANDFG for the reach."""

        self.SANDFG = SANDFG # sand algorithm (1:Toffaleti, 2:Colby, 3:Power) 

    def get_sandfg(self):
        """Returns the SANDFG for the reach."""

        return (self.operation, self.SANDFG)

    def set_genparm(self, BEDWID = None, BEDWRN = None, POR = 0.5):
        """Sets the physical characterstics of the bed. Uses the average flow
        and velocity and assumes a 3:1 width:depth ratio. Since sediment 
        transport is driven by higher flow, assumes 3 times average."""
        
        if not self.lake:

            areasqft = self.flow / self.velocity

            # convert average area to 3x in meters for higher flows

            area     = 3 * areasqft * 0.3048**2
            width    = 3 * math.sqrt(area / 3)
            depth    = math.sqrt(area / 3)

            if BEDWID is None: self.BEDWID = max(0.3, width)    # width (m)
            if BEDWRN is None: self.BEDWRN = max(0.0003, depth) # depth (m)

        else:

            self.BEDWRN = self.dam.height
            self.BEDWID = 10 * math.sqrt(self.dam.max_storage / 10 / 
                                         self.dam.height)

        self.POR = POR  # porostiy (-)

    def get_genparm(self):
        """Returns the SED-GENPARM values."""

        return (self.operation, self.BEDWID, self.BEDWRN, self.POR)

    def set_sand_pm(self, W = 0.5, RHO = 2.5, KSAND = 0.1, EXPSND = 2.):
        """Sets the values for physical properties of the sand particles."""

        # These parameters are not unique in HSPF so had to add "sand"

        self.Dsand   = self.DB50 # effective particle diameter (mm)
        self.Wsand   = W         # sand fall velocity (mm/s); note inconsistency
        self.RHOsand = RHO       # sand particle density (g/cm3)

        # note the following are only used for sandfg = 3

        self.KSAND  = KSAND   # sandload coefficient (complex)
        self.EXPSND = EXPSND  # sandload exponent (-)

    def get_sand_pm(self):
        """Returns the SAND-PM values."""

        return (self.operation, self.Dsand, self.Wsand, self.RHOsand, 
                self.KSAND, self.EXPSND)

    def set_silt_pm(self, D = 0.05, W = 0.007, RHO = 2.65, TAUCD = 0.005,
                    TAUCS = 0.01, M = 0.001):
        """Sets the values for the physical properties of silt."""

        # These parameters are not unique in HSPF so had to add "silt"

        self.Dsilt     = D      # silt diameter (mm)
        self.Wsilt     = W      # silt velocity (mm/s)
        self.RHOsilt   = RHO    # silt particle density (g/cm3)
        self.TAUCDsilt = TAUCD  # silt critical bed shear stress (kg/m2)
        self.TAUCSsilt = TAUCS  # silt critical scour shear stress (kg/m2)
        self.Msilt     = M      # silt erobability coefficient (kg/m2/day)

    def get_silt_pm(self):
        """Returns the SILT-CLAY-PM values (for silt)."""

        return (self.operation, self.Dsilt, self.Wsilt, self.RHOsilt,
                self.TAUCDsilt, self.TAUCSsilt, self.Msilt)

    def set_clay_pm(self, D = 0.01, W = 0.0002, RHO = 2.65, TAUCD = 0.005,
                    TAUCS = 0.01, M = 0.001):
        """Sets the values for the physical properties of silt."""

        # These parameters are not unique in HSPF so had to add "clay"

        self.Dclay     = D      # clay diameter (mm)
        self.Wclay     = W      # clay velocity (mm/s)
        self.RHOclay   = RHO    # clay particle density (g/cm3)
        self.TAUCDclay = TAUCD  # clay critical bed shear stress (kg/m2)
        self.TAUCSclay = TAUCS  # clay critical scour shear stress (kg/m2)
        self.Mclay     = M      # clay erobability coefficient (kg/m2/day)

    def get_clay_pm(self):
        """Returns the SILT-CLAY-PM values (for silt)."""

        return (self.operation, self.Dclay, self.Wclay, self.RHOclay,
                self.TAUCDclay, self.TAUCSclay, self.Mclay)
    
    def set_ssed_init(self, Sand = 5., Silt = 25., Clay = 25.):
        """Sets the initial values for the suspended solids concentrations."""

        self.Sand = Sand  # sand concentration (mg/L)
        self.Silt = Silt  # silt concentration (mg/L)
        self.Clay = Clay  # clay concentration (mg/L)

    def get_ssed_init(self):
        """Returns the initial values for suspended solids concentrations."""

        return (self.operation, self.Sand, self.Silt, self.Clay)

    def set_bed_init(self, BEDDEP = 1., Sand = 0.8, Silt = 0.1, Clay = 0.1):
        """Sets the initial values for the bed depth and particle fractions."""

        # note that again these are not unique names in HSPF so modified

        self.BEDDEP = min(BEDDEP, self.BEDWRN * 0.99)
        self.FSand  = Sand
        self.FSilt  = Silt
        self.FClay  = Clay

    def get_bed_init(self):
        """Returns the BED-INIT values."""

        return(self.operation, self.BEDDEP, self.FSand, self.FSilt, self.FClay) 

